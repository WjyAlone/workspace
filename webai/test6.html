<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIæ‰‹åŠ¿æ§åˆ¶ç²’å­ç‰¹æ•ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
            color: white;
        }
        
        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            font-size: 20px;
            text-align: center;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #00ff88;
            width: 80%;
            max-width: 500px;
        }
        
        .progress-bar {
            width: 100%;
            height: 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            margin: 25px 0;
            overflow: hidden;
            position: relative;
        }
        
        .progress {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #0088ff);
            width: 0%;
            transition: width 0.5s ease-out;
            border-radius: 12px;
        }
        
        .progress-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }
        
        .loading-steps {
            text-align: left;
            margin: 20px 0;
        }
        
        .loading-step {
            margin: 10px 0;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid transparent;
            transition: all 0.3s;
        }
        
        .loading-step.active {
            border-left-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }
        
        .loading-step.completed {
            border-left-color: #0088ff;
            color: #00ff88;
        }
        
        #status {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00ff88;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 18px;
            border-radius: 12px;
            border: 1px solid #00ff88;
            z-index: 100;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        button {
            background: linear-gradient(135deg, #00ff88, #0088ff);
            color: black;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
            min-width: 160px;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.5);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        #handCanvas {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 225px;
            border-radius: 12px;
            border: 3px solid #00ff88;
            z-index: 100;
            transform: scaleX(-1);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
        }
        
        .stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #00ff88;
            font-size: 13px;
            line-height: 1.6;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        .gesture-indicator {
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            font-weight: bold;
            text-align: center;
            border: 1px solid #00ff88;
        }
        
        .fps-counter {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            color: #aaa;
            border: 1px solid #333;
        }
        
        .help-text {
            position: fixed;
            bottom: 80px;
            left: 20px;
            color: #888;
            font-size: 12px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <h2 style="margin-bottom: 20px;">ğŸ® AIæ‰‹åŠ¿æ§åˆ¶ç²’å­ç‰¹æ•ˆ</h2>
        <div class="progress-bar">
            <div class="progress" id="progressBar"></div>
            <div class="progress-text" id="progressText">0%</div>
        </div>
        <div class="loading-steps">
            <div class="loading-step" id="step1">åŠ è½½Three.js...</div>
            <div class="loading-step" id="step2">åŠ è½½TensorFlow.js...</div>
            <div class="loading-step" id="step3">åŠ è½½æ‰‹éƒ¨è¯†åˆ«æ¨¡å‹...</div>
            <div class="loading-step" id="step4">åˆå§‹åŒ–æ‘„åƒå¤´...</div>
            <div class="loading-step" id="step5">åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ...</div>
        </div>
        <div id="errorMessage" style="color:#ff4444; margin-top:20px; display:none;"></div>
    </div>
    
    <!-- Main Canvas -->
    <div id="container"></div>
    
    <!-- UI Elements -->
    <div id="status" style="display:none;">æ­£åœ¨åˆå§‹åŒ–...</div>
    <div id="controls" style="display:none;">
        <button id="toggleHandView">æ˜¾ç¤º/éšè—æ‰‹éƒ¨æ£€æµ‹</button>
        <button id="changeColor">åˆ‡æ¢ç²’å­é¢œè‰²</button>
        <button id="changeShape">åˆ‡æ¢ç²’å­å½¢çŠ¶</button>
        <button id="toggleAutoRotate">è‡ªåŠ¨æ—‹è½¬: å¼€å¯</button>
    </div>
    
    <!-- Hand Detection Canvas -->
    <canvas id="handCanvas" style="display:none;"></canvas>
    
    <!-- Stats Panel -->
    <div class="stats" style="display:none;">
        <div><strong>ğŸ¯ æ‰‹éƒ¨çŠ¶æ€:</strong> <span id="handStatus">æœªæ£€æµ‹åˆ°</span></div>
        <div><strong>ğŸ¤š ç½®ä¿¡åº¦:</strong> <span id="confidence">0%</span></div>
        <div><strong>âœ‹ æ‰‹åŠ¿:</strong> <span id="gestureName">æ— </span></div>
        <div><strong>ğŸ“ ä½ç½®:</strong> X:<span id="handX">0</span> Y:<span id="handY">0</span></div>
        <div class="gesture-indicator" id="gestureIndicator">ç­‰å¾…æ‰‹åŠ¿...</div>
    </div>
    
    <!-- FPS Counter -->
    <div class="fps-counter" style="display:none;">FPS: <span id="fps">0</span></div>
    
    <!-- Help Text -->
    <div class="help-text" style="display:none;">
        æç¤ºï¼šåœ¨æ‘„åƒå¤´å‰å±•ç¤ºæ‰‹éƒ¨ï¼Œè·ç¦»é€‚ä¸­ï¼Œç¡®ä¿å…‰çº¿å……è¶³
    </div>
    
    <!-- Video for processing -->
    <video id="inputVideo" style="display:none;" autoplay playsinline></video>

    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <!-- TensorFlow HandPose Model -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ========== å…¨å±€å˜é‡ ==========
        let scene, camera, renderer, particles;
        let handCanvas, handCtx;
        let handDetector = null;
        let isHandDetected = false;
        let autoRotate = true;
        
        // æ‰‹éƒ¨æ•°æ®
        let handData = {
            position: { x: 0, y: 0, z: 0 },
            landmarks: [],
            confidence: 0,
            gesture: 'none',
            scale: 1.0,
            velocity: { x: 0, y: 0 },
            smoothedPosition: { x: 0, y: 0 },
            history: []
        };
        
        // é…ç½®
        const CONFIG = {
            particleCount: 10000,
            particleSize: 0.1,
            colors: ['#00ff88', '#0088ff', '#ff0088', '#ffaa00', '#aa00ff'],
            shapes: ['sphere', 'cube', 'torus', 'heart', 'spiral', 'galaxy'],
            fps: 0,
            frameCount: 0,
            lastTime: performance.now()
        };
        
        // ========== åŠ è½½ç®¡ç† ==========
        let loadProgress = {
            threejs: false,
            tfjs: false,
            handpose: false,
            camera: false,
            particles: false
        };
        
        function updateLoading() {
            const totalSteps = 5;
            const completedSteps = Object.values(loadProgress).filter(v => v).length;
            const progress = (completedSteps / totalSteps) * 100;
            
            document.getElementById('progressBar').style.width = `${progress}%`;
            document.getElementById('progressText').textContent = `${Math.round(progress)}%`;
            
            // æ›´æ–°æ­¥éª¤çŠ¶æ€
            document.getElementById('step1').className = 
                `loading-step ${loadProgress.threejs ? 'completed' : 'active'}`;
            document.getElementById('step2').className = 
                `loading-step ${loadProgress.tfjs ? 'completed' : (loadProgress.threejs ? 'active' : '')}`;
            document.getElementById('step3').className = 
                `loading-step ${loadProgress.handpose ? 'completed' : (loadProgress.tfjs ? 'active' : '')}`;
            document.getElementById('step4').className = 
                `loading-step ${loadProgress.camera ? 'completed' : (loadProgress.handpose ? 'active' : '')}`;
            document.getElementById('step5').className = 
                `loading-step ${loadProgress.particles ? 'completed' : (loadProgress.camera ? 'active' : '')}`;
            
            // æ‰€æœ‰æ­¥éª¤å®Œæˆ
            if (completedSteps === totalSteps) {
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status').style.display = 'block';
                    document.getElementById('controls').style.display = 'flex';
                    document.getElementById('handCanvas').style.display = 'block';
                    document.querySelector('.stats').style.display = 'block';
                    document.querySelector('.fps-counter').style.display = 'block';
                    document.querySelector('.help-text').style.display = 'block';
                    updateStatus("âœ… AIæ‰‹åŠ¿æ§åˆ¶å·²å°±ç»ªï¼");
                }, 1000);
            }
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // ========== 1. åˆå§‹åŒ–Three.js ==========
        function initThreeJS() {
            try {
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.jsæœªåŠ è½½');
                }
                
                // åˆ›å»ºåœºæ™¯
                scene = new THREE.Scene();
                
                // åˆ›å»ºç›¸æœº
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 25;
                camera.position.y = 5;
                
                // åˆ›å»ºæ¸²æŸ“å™¨
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio || 1);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('container').appendChild(renderer.domElement);
                
                // æ·»åŠ ç¯å…‰
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 15);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // æ·»åŠ é“¶æ²³èƒŒæ™¯
                createGalaxyBackground();
                
                loadProgress.threejs = true;
                updateLoading();
                console.log("âœ… Three.jsåˆå§‹åŒ–å®Œæˆ");
                
            } catch (error) {
                console.error("âŒ Three.jsåˆå§‹åŒ–å¤±è´¥:", error);
                document.getElementById('errorMessage').style.display = 'block';
                document.getElementById('errorMessage').textContent = `Three.jsé”™è¯¯: ${error.message}`;
            }
        }
        
        // åˆ›å»ºé“¶æ²³èƒŒæ™¯
        function createGalaxyBackground() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 5000;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                const radius = Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i + 2] = radius * Math.cos(phi);
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 0.2,
                color: 0x8888ff,
                transparent: true,
                opacity: 0.8
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        // ========== 2. åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ ==========
        function initParticles() {
            try {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(CONFIG.particleCount * 3);
                const colors = new Float32Array(CONFIG.particleCount * 3);
                const velocities = new Float32Array(CONFIG.particleCount * 3);
                
                const baseColor = new THREE.Color(CONFIG.colors[0]);
                
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const i3 = i * 3;
                    
                    // åˆå§‹ä½ç½®ï¼ˆçƒä½“åˆ†å¸ƒï¼‰
                    const radius = 10;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(Math.random() * 2 - 1);
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = radius * Math.cos(phi);
                    
                    // é¢œè‰²ï¼ˆæ¸å˜ï¼‰
                    const hue = i / CONFIG.particleCount;
                    const color = new THREE.Color().setHSL(hue, 0.8, 0.5);
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                    
                    // éšæœºé€Ÿåº¦
                    velocities[i3] = (Math.random() - 0.5) * 0.02;
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
                    velocities[i3 + 2] = (Math.random() - 0.5) * 0.02;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                
                const material = new THREE.PointsMaterial({
                    size: CONFIG.particleSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    sizeAttenuation: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                particles = new THREE.Points(geometry, material);
                scene.add(particles);
                
                loadProgress.particles = true;
                updateLoading();
                console.log("âœ… ç²’å­ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
                
            } catch (error) {
                console.error("âŒ ç²’å­ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:", error);
            }
        }
        
        // ========== 3. åˆå§‹åŒ–TensorFlow.jså’ŒHandPose ==========
        async function initTensorFlow() {
            try {
                // æ£€æŸ¥TensorFlow.js
                if (typeof tf === 'undefined') {
                    throw new Error('TensorFlow.jsæœªåŠ è½½');
                }
                
                loadProgress.tfjs = true;
                updateLoading();
                
                // åŠ è½½HandPoseæ¨¡å‹
                console.log("æ­£åœ¨åŠ è½½æ‰‹éƒ¨è¯†åˆ«æ¨¡å‹...");
                handDetector = await handpose.load();
                console.log("âœ… HandPoseæ¨¡å‹åŠ è½½å®Œæˆ");
                
                loadProgress.handpose = true;
                updateLoading();
                
            } catch (error) {
                console.error("âŒ TensorFlow/HandPoseåˆå§‹åŒ–å¤±è´¥:", error);
                document.getElementById('errorMessage').style.display = 'block';
                document.getElementById('errorMessage').textContent = `AIæ¨¡å‹é”™è¯¯: ${error.message}`;
                
                // ä½¿ç”¨å¤‡ç”¨æ¨¡å¼
                setTimeout(() => {
                    loadProgress.handpose = true;
                    loadProgress.camera = true;
                    updateLoading();
                    updateStatus("âš ï¸ ä½¿ç”¨å¤‡ç”¨é¼ æ ‡æ§åˆ¶æ¨¡å¼");
                }, 2000);
            }
        }
        
        // ========== 4. åˆå§‹åŒ–æ‘„åƒå¤´ ==========
        async function initCamera() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´');
                }
                
                // è·å–æ‘„åƒå¤´
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user',
                        frameRate: { ideal: 30 }
                    }
                });
                
                const video = document.getElementById('inputVideo');
                video.srcObject = stream;
                await video.play();
                
                // åˆå§‹åŒ–æ‰‹éƒ¨æ£€æµ‹Canvas
                handCanvas = document.getElementById('handCanvas');
                handCtx = handCanvas.getContext('2d');
                handCanvas.width = 300;
                handCanvas.height = 225;
                
                loadProgress.camera = true;
                updateLoading();
                console.log("âœ… æ‘„åƒå¤´åˆå§‹åŒ–å®Œæˆ");
                
                // å¼€å§‹æ‰‹éƒ¨æ£€æµ‹
                if (handDetector) {
                    detectHands(video);
                } else {
                    startMouseControl();
                }
                
            } catch (error) {
                console.error("âŒ æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:", error);
                updateStatus("âš ï¸ æ‘„åƒå¤´æ— æ³•è®¿é—®ï¼Œä½¿ç”¨é¼ æ ‡æ§åˆ¶");
                
                loadProgress.camera = true;
                updateLoading();
                
                // ä½¿ç”¨é¼ æ ‡æ§åˆ¶
                startMouseControl();
            }
        }
        
        // ========== 5. æ‰‹éƒ¨æ£€æµ‹å‡½æ•° ==========
        async function detectHands(video) {
            async function detectFrame() {
                try {
                    // ä½¿ç”¨TensorFlow.jsæ£€æµ‹æ‰‹éƒ¨
                    const predictions = await handDetector.estimateHands(video);
                    
                    // æ¸…ç©ºCanvas
                    handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
                    
                    // ç»˜åˆ¶è§†é¢‘å¸§
                    handCtx.save();
                    handCtx.scale(-1, 1);
                    handCtx.translate(-handCanvas.width, 0);
                    handCtx.drawImage(video, 0, 0, handCanvas.width, handCanvas.height);
                    handCtx.restore();
                    
                    if (predictions.length > 0) {
                        const hand = predictions[0];
                        isHandDetected = true;
                        
                        // æå–æ‰‹éƒ¨å…³é”®ç‚¹
                        handData.landmarks = hand.landmarks;
                        handData.confidence = hand.handInViewConfidence;
                        
                        // è®¡ç®—æ‰‹éƒ¨ä¸­å¿ƒä½ç½®ï¼ˆä½¿ç”¨æ‰‹è…•å’Œæ‰‹æŒç‚¹ï¼‰
                        const wrist = hand.landmarks[0];      // æ‰‹è…•
                        const palmBase = hand.landmarks[9];   // æ‰‹æŒä¸­å¿ƒ
                        
                        // è½¬æ¢ä¸ºCanvasåæ ‡
                        const scaleX = handCanvas.width / video.videoWidth;
                        const scaleY = handCanvas.height / video.videoHeight;
                        
                        const wristX = wrist[0] * scaleX;
                        const wristY = wrist[1] * scaleY;
                        const palmX = palmBase[0] * scaleX;
                        const palmY = palmBase[1] * scaleY;
                        
                        // æ‰‹éƒ¨ä¸­å¿ƒä½ç½®
                        const centerX = (wristX + palmX) / 2;
                        const centerY = (wristY + palmY) / 2;
                        
                        // å¹³æ»‘å¤„ç†
                        handData.history.push({ x: centerX, y: centerY });
                        if (handData.history.length > 10) {
                            handData.history.shift();
                        }
                        
                        const avgX = handData.history.reduce((sum, p) => sum + p.x, 0) / handData.history.length;
                        const avgY = handData.history.reduce((sum, p) => sum + p.y, 0) / handData.history.length;
                        
                        // è®¡ç®—é€Ÿåº¦
                        if (handData.history.length > 1) {
                            const lastPos = handData.history[handData.history.length - 2];
                            handData.velocity.x = avgX - lastPos.x;
                            handData.velocity.y = avgY - lastPos.y;
                        }
                        
                        // æ˜ å°„åˆ°3Dç©ºé—´
                        handData.position.x = (avgX / handCanvas.width - 0.5) * 20;
                        handData.position.y = -(avgY / handCanvas.height - 0.5) * 15;
                        
                        // è®¡ç®—æ‰‹éƒ¨å¤§å°ï¼ˆç”¨äºç¼©æ”¾ï¼‰
                        const handWidth = Math.abs(wristX - palmX);
                        const handHeight = Math.abs(wristY - palmY);
                        const handSize = Math.sqrt(handWidth * handWidth + handHeight * handHeight);
                        handData.scale = 0.5 + (handSize / 100) * 1.5;
                        
                        // æ£€æµ‹æ‰‹åŠ¿
                        detectGesture(hand.landmarks);
                        
                        // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹
                        drawHandLandmarks(hand.landmarks, scaleX, scaleY);
                        
                        // ç»˜åˆ¶æ‰‹éƒ¨è½®å»“
                        drawHandContour(hand.landmarks, scaleX, scaleY);
                        
                        // ç»˜åˆ¶æ‰‹éƒ¨ä¸­å¿ƒ
                        handCtx.fillStyle = '#00ff88';
                        handCtx.beginPath();
                        handCtx.arc(avgX, avgY, 8 + handData.scale * 5, 0, Math.PI * 2);
                        handCtx.fill();
                        
                        handCtx.strokeStyle = '#ffffff';
                        handCtx.lineWidth = 2;
                        handCtx.stroke();
                        
                        // ç»˜åˆ¶ä¿¡æ¯
                        handCtx.fillStyle = '#ffffff';
                        handCtx.font = '14px Arial';
                        handCtx.fillText(`æ‰‹éƒ¨æ£€æµ‹ âœ“`, 10, 20);
                        handCtx.fillText(`ç½®ä¿¡åº¦: ${Math.round(handData.confidence * 100)}%`, 10, 40);
                        handCtx.fillText(`æ‰‹åŠ¿: ${handData.gesture}`, 10, 60);
                        
                        // æ›´æ–°UI
                        updateHandUI();
                        
                    } else {
                        isHandDetected = false;
                        handData.gesture = 'none';
                        updateHandUI();
                    }
                    
                } catch (error) {
                    console.warn('æ‰‹éƒ¨æ£€æµ‹é”™è¯¯:', error);
                    isHandDetected = false;
                }
                
                // ä¸‹ä¸€å¸§
                requestAnimationFrame(detectFrame);
            }
            
            // å¼€å§‹æ£€æµ‹
            detectFrame();
        }
        
        // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹
        function drawHandLandmarks(landmarks, scaleX, scaleY) {
            handCtx.fillStyle = '#ff3333';
            
            // ç»˜åˆ¶æ‰€æœ‰å…³é”®ç‚¹
            landmarks.forEach((landmark, index) => {
                const x = landmark[0] * scaleX;
                const y = landmark[1] * scaleY;
                
                handCtx.beginPath();
                handCtx.arc(x, y, 3, 0, Math.PI * 2);
                handCtx.fill();
                
                // ç»˜åˆ¶å…³é”®ç‚¹ç¼–å·ï¼ˆè°ƒè¯•ç”¨ï¼‰
                if (index === 0 || index === 4 || index === 8 || index === 12 || index === 16 || index === 20) {
                    handCtx.fillStyle = '#ffffff';
                    handCtx.font = '10px Arial';
                    handCtx.fillText(index, x + 5, y - 5);
                    handCtx.fillStyle = '#ff3333';
                }
            });
        }
        
        // ç»˜åˆ¶æ‰‹éƒ¨è½®å»“
        function drawHandContour(landmarks, scaleX, scaleY) {
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4],        // æ‹‡æŒ‡
                [0, 5], [5, 6], [6, 7], [7, 8],        // é£ŸæŒ‡
                [0, 9], [9, 10], [10, 11], [11, 12],   // ä¸­æŒ‡
                [0, 13], [13, 14], [14, 15], [15, 16], // æ— åæŒ‡
                [0, 17], [17, 18], [18, 19], [19, 20], // å°æŒ‡
                [5, 9], [9, 13], [13, 17]              // æ‰‹æŒ
            ];
            
            handCtx.strokeStyle = '#00ff88';
            handCtx.lineWidth = 2;
            handCtx.beginPath();
            
            connections.forEach(([start, end]) => {
                const startX = landmarks[start][0] * scaleX;
                const startY = landmarks[start][1] * scaleY;
                const endX = landmarks[end][0] * scaleX;
                const endY = landmarks[end][1] * scaleY;
                
                handCtx.moveTo(startX, startY);
                handCtx.lineTo(endX, endY);
            });
            
            handCtx.stroke();
        }
        
        // æ£€æµ‹æ‰‹åŠ¿
        function detectGesture(landmarks) {
            // è·å–å…³é”®ç‚¹
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];
            
            // è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»
            const distances = [
                distance(thumbTip, wrist),
                distance(indexTip, wrist),
                distance(middleTip, wrist),
                distance(ringTip, wrist),
                distance(pinkyTip, wrist)
            ];
            
            // æ‰‹æŒå¼ å¼€åº¦ï¼ˆæ‰€æœ‰æŒ‡å°–è·ç¦»çš„å¹³å‡å€¼ï¼‰
            const openness = distances.reduce((sum, d) => sum + d, 0) / distances.length;
            
            // æ£€æµ‹æ‹³å¤´ï¼ˆæ‰€æœ‰æŒ‡å°–éƒ½é è¿‘æ‰‹è…•ï¼‰
            const isFist = distances.every(d => d < 100);
            
            // æ£€æµ‹å¼ å¼€æ‰‹
            const isOpen = distances.every(d => d > 150) && openness > 200;
            
            // æ£€æµ‹å‰ªåˆ€æ‰‹ï¼ˆVå­—æ‰‹åŠ¿ï¼‰
            const indexToMiddle = distance(indexTip, middleTip);
            const isVictory = distances[1] > 150 && distances[2] > 150 && 
                            indexToMiddle > 50 && distances[0] < 100 && 
                            distances[3] < 100 && distances[4] < 100;
            
            // æ£€æµ‹OKæ‰‹åŠ¿ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡æ¥è§¦ï¼‰
            const thumbToIndex = distance(thumbTip, indexTip);
            const isOK = thumbToIndex < 30 && distances[2] > 100;
            
            // è®¾ç½®æ‰‹åŠ¿ç±»å‹
            if (isVictory) {
                handData.gesture = 'victory âœŒï¸';
            } else if (isOK) {
                handData.gesture = 'ok ğŸ‘Œ';
            } else if (isFist) {
                handData.gesture = 'fist âœŠ';
            } else if (isOpen) {
                handData.gesture = 'open ğŸ–ï¸';
            } else if (openness > 180) {
                handData.gesture = 'moving âœ‹';
            } else {
                handData.gesture = 'unknown';
            }
        }
        
        // è®¡ç®—ä¸¤ç‚¹è·ç¦»
        function distance(point1, point2) {
            const dx = point1[0] - point2[0];
            const dy = point1[1] - point2[1];
            const dz = point1[2] - point2[2];
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        
        // æ›´æ–°æ‰‹éƒ¨UI
        function updateHandUI() {
            document.getElementById('handStatus').textContent = 
                isHandDetected ? 'å·²æ£€æµ‹' : 'æœªæ£€æµ‹';
            document.getElementById('handStatus').style.color = 
                isHandDetected ? '#00ff88' : '#ff4444';
                
            document.getElementById('confidence').textContent = 
                `${Math.round(handData.confidence * 100)}%`;
            document.getElementById('gestureName').textContent = handData.gesture;
            document.getElementById('handX').textContent = handData.position.x.toFixed(1);
            document.getElementById('handY').textContent = handData.position.y.toFixed(1);
            
            const indicator = document.getElementById('gestureIndicator');
            indicator.textContent = isHandDetected ? 
                `æ‰‹åŠ¿: ${handData.gesture}` : 'ç­‰å¾…æ£€æµ‹æ‰‹éƒ¨...';
            indicator.style.background = isHandDetected ? 
                'rgba(0, 255, 136, 0.3)' : 'rgba(255, 68, 68, 0.3)';
            indicator.style.borderColor = isHandDetected ? '#00ff88' : '#ff4444';
        }
        
        // ========== 6. é¼ æ ‡æ§åˆ¶ï¼ˆå¤‡ç”¨ï¼‰ ==========
        function startMouseControl() {
            console.log("å¯åŠ¨é¼ æ ‡æ§åˆ¶æ¨¡å¼");
            
            let mouseX = 0;
            let mouseY = 0;
            let mouseDown = false;
            
            // é¼ æ ‡ç§»åŠ¨
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                isHandDetected = true;
                handData.position.x = (mouseX / window.innerWidth - 0.5) * 20;
                handData.position.y = -(mouseY / window.innerHeight - 0.5) * 15;
                handData.scale = mouseDown ? 0.7 : 1.3;
                handData.gesture = mouseDown ? 'fist âœŠ' : 'open ğŸ–ï¸';
                
                // æ›´æ–°æ‰‹éƒ¨Canvas
                if (handCtx) {
                    handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
                    handCtx.fillStyle = '#0088ff';
                    handCtx.font = '16px Arial';
                    handCtx.fillText('é¼ æ ‡æ§åˆ¶æ¨¡å¼', 10, 30);
                    handCtx.fillText('ç§»åŠ¨é¼ æ ‡æ§åˆ¶ç²’å­', 10, 55);
                    handCtx.fillText('ç‚¹å‡»: æ¡æ‹³, é‡Šæ”¾: å¼ å¼€', 10, 80);
                    
                    // ç»˜åˆ¶é¼ æ ‡ä½ç½®
                    const canvasX = mouseX * (handCanvas.width / window.innerWidth);
                    const canvasY = mouseY * (handCanvas.height / window.innerHeight);
                    
                    handCtx.fillStyle = '#0088ff';
                    handCtx.beginPath();
                    handCtx.arc(canvasX, canvasY, 15, 0, Math.PI * 2);
                    handCtx.fill();
                }
                
                updateHandUI();
            });
            
            // é¼ æ ‡ç‚¹å‡»
            document.addEventListener('mousedown', () => {
                mouseDown = true;
                handData.gesture = 'fist âœŠ';
                handData.scale = 0.7;
                updateHandUI();
            });
            
            document.addEventListener('mouseup', () => {
                mouseDown = false;
                handData.gesture = 'open ğŸ–ï¸';
                handData.scale = 1.3;
                updateHandUI();
            });
            
            document.addEventListener('mouseleave', () => {
                isHandDetected = false;
                updateHandUI();
            });
        }
        
        // ========== 7. åŠ¨ç”»å¾ªç¯ ==========
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            CONFIG.frameCount++;
            
            // è®¡ç®—FPS
            if (currentTime > CONFIG.lastTime + 1000) {
                CONFIG.fps = Math.round((CONFIG.frameCount * 1000) / (currentTime - CONFIG.lastTime));
                document.getElementById('fps').textContent = CONFIG.fps;
                CONFIG.frameCount = 0;
                CONFIG.lastTime = currentTime;
            }
            
            const time = currentTime * 0.001;
            
            // æ›´æ–°ç²’å­
            if (particles) {
                const positions = particles.geometry.attributes.position.array;
                const velocities = particles.geometry.attributes.velocity.array;
                
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const i3 = i * 3;
                    
                    const px = positions[i3];
                    const py = positions[i3 + 1];
                    const pz = positions[i3 + 2];
                    
                    // æ‰‹éƒ¨å½±å“
                    if (isHandDetected) {
                        const dx = px - handData.position.x;
                        const dy = py - handData.position.y;
                        const dz = pz - handData.position.z;
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        if (distance < 8) {
                            // æ‰‹éƒ¨é™„è¿‘çš„ç²’å­è¢«æ¨å¼€
                            const force = 0.4 * (1 - distance / 8);
                            positions[i3] = px + (dx / distance) * force;
                            positions[i3 + 1] = py + (dy / distance) * force;
                            positions[i3 + 2] = pz + (dz / distance) * force;
                            
                            // æ‰‹åŠ¿ç‰¹æ•ˆ
                            if (handData.gesture.includes('fist')) {
                                // æ¡æ‹³ï¼šç²’å­æ”¶ç¼©
                                positions[i3] *= 0.95;
                                positions[i3 + 1] *= 0.95;
                                positions[i3 + 2] *= 0.95;
                            } else if (handData.gesture.includes('open')) {
                                // å¼ å¼€ï¼šç²’å­æ‰©å¼ 
                                positions[i3] *= 1.05;
                                positions[i3 + 1] *= 1.05;
                                positions[i3 + 2] *= 1.05;
                            } else if (handData.gesture.includes('victory')) {
                                // Væ‰‹åŠ¿ï¼šæ—‹è½¬ç‰¹æ•ˆ
                                const angle = time * 2;
                                const radius = Math.sqrt(px * px + pz * pz);
                                positions[i3] = Math.cos(angle) * radius;
                                positions[i3 + 2] = Math.sin(angle) * radius;
                            }
                        }
                    }
                    
                    // åº”ç”¨ç¼©æ”¾
                    positions[i3] *= handData.scale;
                    positions[i3 + 1] *= handData.scale;
                    positions[i3 + 2] *= handData.scale;
                    
                    // æ·»åŠ éšæœºè¿åŠ¨
                    positions[i3] += velocities[i3];
                    positions[i3 + 1] += velocities[i3 + 1];
                    positions[i3 + 2] += velocities[i3 + 2];
                    
                    // è¾¹ç•Œæ£€æŸ¥
                    const boundary = 15;
                    if (Math.abs(positions[i3]) > boundary) velocities[i3] *= -1;
                    if (Math.abs(positions[i3 + 1]) > boundary) velocities[i3 + 1] *= -1;
                    if (Math.abs(positions[i3 + 2]) > boundary) velocities[i3 + 2] *= -1;
                    
                    // è‡ªç„¶æ³¢åŠ¨
                    positions[i3] += Math.sin(time + i * 0.01) * 0.02;
                    positions[i3 + 1] += Math.cos(time * 0.7 + i * 0.01) * 0.02;
                    positions[i3 + 2] += Math.sin(time * 0.5 + i * 0.01) * 0.02;
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                
                // è‡ªåŠ¨æ—‹è½¬ç›¸æœº
                if (autoRotate && !isHandDetected) {
                    camera.position.x = Math.sin(time * 0.1) * 30;
                    camera.position.z = Math.cos(time * 0.1) * 30;
                    camera.lookAt(0, 0, 0);
                } else if (isHandDetected) {
                    // è·Ÿéšæ‰‹éƒ¨
                    const targetX = handData.position.x * 0.5;
                    const targetY = handData.position.y * 0.5 + 10;
                    const targetZ = 25;
                    
                    camera.position.x += (targetX - camera.position.x) * 0.05;
                    camera.position.y += (targetY - camera.position.y) * 0.05;
                    camera.position.z += (targetZ - camera.position.z) * 0.05;
                    
                    camera.lookAt(handData.position.x, handData.position.y, 0);
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // ========== 8. åˆå§‹åŒ–åº”ç”¨ ==========
        async function initApp() {
            try {
                console.log("å¼€å§‹åˆå§‹åŒ–åº”ç”¨...");
                
                // 1. åˆå§‹åŒ–Three.js
                initThreeJS();
                
                // 2. åˆå§‹åŒ–TensorFlow.jså’ŒHandPose
                await initTensorFlow();
                
                // 3. åˆå§‹åŒ–æ‘„åƒå¤´
                await initCamera();
                
                // 4. åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
                initParticles();
                
                // 5. å¼€å§‹åŠ¨ç”»
                animate();
                
                // 6. è®¾ç½®UIäº‹ä»¶
                setupUIEvents();
                
                // 7. è®¾ç½®çª—å£è°ƒæ•´äº‹ä»¶
                window.addEventListener('resize', onWindowResize);
                
                console.log("âœ… åº”ç”¨åˆå§‹åŒ–å®Œæˆ");
                
            } catch (error) {
                console.error("âŒ åº”ç”¨åˆå§‹åŒ–å¤±è´¥:", error);
                document.getElementById('errorMessage').style.display = 'block';
                document.getElementById('errorMessage').textContent = `åˆå§‹åŒ–é”™è¯¯: ${error.message}`;
            }
        }
        
        // è®¾ç½®UIäº‹ä»¶
        function setupUIEvents() {
            document.getElementById('toggleHandView').addEventListener('click', function() {
                const canvas = document.getElementById('handCanvas');
                canvas.style.display = canvas.style.display === 'none' ? 'block' : 'none';
                this.textContent = canvas.style.display === 'none' ? 'æ˜¾ç¤ºæ‰‹éƒ¨æ£€æµ‹' : 'éšè—æ‰‹éƒ¨æ£€æµ‹';
            });
            
            document.getElementById('changeColor').addEventListener('click', function() {
                if (!particles) return;
                
                const colors = particles.geometry.attributes.color.array;
                const hue = Math.random();
                const color = new THREE.Color().setHSL(hue, 0.8, 0.5);
                
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const i3 = i * 3;
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                }
                
                particles.geometry.attributes.color.needsUpdate = true;
            });
            
            document.getElementById('changeShape').addEventListener('click', function() {
                if (!particles) return;
                
                const positions = particles.geometry.attributes.position.array;
                const shape = CONFIG.shapes[Math.floor(Math.random() * CONFIG.shapes.length)];
                
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const i3 = i * 3;
                    let x, y, z;
                    
                    switch(shape) {
                        case 'torus':
                            const angle = (i / CONFIG.particleCount) * Math.PI * 2;
                            const radius = 8;
                            const tube = 3;
                            x = (radius + tube * Math.cos(angle * 5)) * Math.cos(angle);
                            y = (radius + tube * Math.cos(angle * 5)) * Math.sin(angle);
                            z = tube * Math.sin(angle * 5);
                            break;
                        case 'galaxy':
                            const galAngle = (i / CONFIG.particleCount) * Math.PI * 4;
                            const galRadius = 2 + Math.random() * 8;
                            x = Math.cos(galAngle) * galRadius;
                            y = (Math.random() - 0.5) * 3;
                            z = Math.sin(galAngle) * galRadius;
                            break;
                        default:
                            // ä¿æŒå½“å‰å½¢çŠ¶
                            return;
                    }
                    
                    positions[i3] = x;
                    positions[i3 + 1] = y;
                    positions[i3 + 2] = z;
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
            });
            
            document.getElementById('toggleAutoRotate').addEventListener('click', function() {
                autoRotate = !autoRotate;
                this.textContent = `è‡ªåŠ¨æ—‹è½¬: ${autoRotate ? 'å¼€å¯' : 'å…³é—­'}`;
            });
            
            // é”®ç›˜å¿«æ·é”®
            document.addEventListener('keydown', (e) => {
                switch(e.key.toLowerCase()) {
                    case ' ':
                        document.getElementById('changeShape').click();
                        break;
                    case 'c':
                        document.getElementById('changeColor').click();
                        break;
                    case 'h':
                        document.getElementById('toggleHandView').click();
                        break;
                    case 'r':
                        autoRotate = !autoRotate;
                        document.getElementById('toggleAutoRotate').textContent = 
                            `è‡ªåŠ¨æ—‹è½¬: ${autoRotate ? 'å¼€å¯' : 'å…³é—­'}`;
                        break;
                }
            });
        }
        
        // çª—å£è°ƒæ•´å¤§å°
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // é¡µé¢åŠ è½½åå¯åŠ¨
        window.addEventListener('load', initApp);
    </script>
</body>
</html>