<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ¢¦å¹»äº’åŠ¨éŸ³ä¹åœ£è¯æ ‘ - Ultimate Stable</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; outline: none; }
        
        /* é”™è¯¯æ—¥å¿—å° (å±å¹•æ˜¾ç¤º) */
        #debug-console {
            position: absolute; top: 0; left: 0; width: 100%; max-height: 200px;
            background: rgba(50, 0, 0, 0.8); color: #ffcccc; 
            font-family: monospace; font-size: 12px; 
            overflow-y: auto; pointer-events: none; z-index: 9999;
            padding: 10px; display: none; /* é»˜è®¤éšè—ï¼Œæœ‰é”™æ‰æ˜¾ */
        }

        #start-screen {
            position: absolute; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; pointer-events: auto; backdrop-filter: blur(10px); z-index: 999;
            transition: opacity 0.5s;
        }
        
        .hero-btn {
            padding: 15px 50px; font-size: 1.2rem; font-weight: bold;
            background: linear-gradient(135deg, #ff3366, #ff6b6b);
            border: none; border-radius: 50px; color: white;
            cursor: pointer; box-shadow: 0 0 30px rgba(255, 51, 102, 0.5);
            transition: all 0.3s; margin-top: 30px; letter-spacing: 2px;
        }
        .hero-btn:hover { transform: scale(1.1); box-shadow: 0 0 50px rgba(255, 51, 102, 0.8); }

        #record-btn {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 60px; height: 60px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255,255,255,0.5);
            cursor: pointer; pointer-events: auto; display: none;
            justify-content: center; align-items: center; transition: all 0.3s; z-index: 100;
        }
        #record-btn .inner { width: 25px; height: 25px; background: #ff3366; border-radius: 50%; transition: all 0.3s; }
        #record-btn.recording { border-color: #ff3366; background: rgba(255, 51, 102, 0.1); }
        #record-btn.recording .inner { transform: scale(0.6); border-radius: 4px; } 

        #video-preview {
            position: absolute; bottom: 20px; left: 20px; width: 120px; height: 90px;
            border-radius: 8px; opacity: 0.6; transform: scaleX(-1); border: 1px solid rgba(255,255,255,0.3);
            pointer-events: auto; transition: opacity 0.3s; z-index: 90; background: #000;
        }
        
        .loading-text { font-family: monospace; color: #00ffcc; margin-top: 10px; font-size: 0.9rem; text-align: center;}
        #file-inputs { display: none; }
    </style>
</head>
<body>
    <div id="debug-console"></div>

    <div id="file-inputs">
        <input type="file" id="music-upload" accept="audio/*">
        <input type="file" id="photo-upload" accept="image/*" multiple>
    </div>
    
    <video id="input-video" style="display:none;" playsinline></video>
    
    <div id="start-screen">
        <h1 style="text-shadow: 0 0 30px #ff3366; margin-bottom: 0;">ğŸ„ Christmas Tree V3.0</h1>
        <p style="color: #aaa; font-size: 0.9rem;">Engineer Edition â€¢ Stable</p>
        
        <div style="text-align: left; background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin: 20px;">
            <p>âœ‹ <b>å·¦æ‰‹:</b> å¼ å¼€æ§åˆ¶çˆ†ç‚¸ (å˜è‰²)</p>
            <p>ğŸ«° <b>å³æ‰‹:</b> æåˆå¬å”¤ç…§ç‰‡å¢™</p>
            <p style="font-size: 0.8rem; color: #ff6b6b;" id="status-msg">æ­£åœ¨æ£€æŸ¥è¿è¡Œç¯å¢ƒ...</p>
        </div>

        <button id="start-btn" class="hero-btn">è¿›å…¥ç³»ç»Ÿ</button>
    </div>

    <div id="record-btn" title="Start Recording"><div class="inner"></div></div>
    <canvas id="video-preview"></canvas>

    <script>
        const debugConsole = document.getElementById('debug-console');
        function logError(msg) {
            debugConsole.style.display = 'block';
            debugConsole.innerHTML += `<div>âŒ ${msg}</div>`;
            console.error(msg);
        }
        function logInfo(msg) {
            debugConsole.innerHTML += `<div>â„¹ï¸ ${msg}</div>`;
            console.log(msg);
        }
        window.onerror = function(msg, source, lineno) {
            logError(`Runtime Error: ${msg} (Line ${lineno})`);
        };
        // æ£€æŸ¥æ˜¯å¦åœ¨æœ¬åœ°æ–‡ä»¶è¿è¡Œ
        if (window.location.protocol === 'file:') {
            logError("ä¸¥é‡è­¦å‘Š: è¯·å‹¿ç›´æ¥åŒå‡»æ‰“å¼€ html æ–‡ä»¶ï¼å¿…é¡»ä½¿ç”¨ VS Code Live Server è¿è¡Œï¼Œå¦åˆ™æ— æ³•åŠ è½½æ‘„åƒå¤´å’Œ WebGLã€‚");
            document.getElementById('status-msg').innerText = "âŒ é”™è¯¯: è¯·ä½¿ç”¨æœåŠ¡å™¨è¿è¡Œ (Live Server)";
            document.getElementById('start-btn').disabled = true;
            document.getElementById('start-btn').innerText = "ç¯å¢ƒé”™è¯¯";
            document.getElementById('start-btn').style.background = "#555";
        }
    </script>

    <!-- ç§»é™¤åŸæœ¬çš„ importmap å’Œå¤–éƒ¨è„šæœ¬å¼•ç”¨ï¼Œæ”¹ä¸ºå†…è” -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import GUI from 'https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.module.min.js';

        // --- å…¨å±€å˜é‡ ---
        const params = {
            treeHeight: 35, treeRadius: 12, particleCount: 5000, particleSize: 1.5,
            snowCount: 1000, snowSpeed: 1.0, windStrength: 0.5, bgStyle: 'Deep Space',
            audioSens: 1.5, reactionSpeed: 0.2, showSnowman: true,
            uploadMusic: () => document.getElementById('music-upload').click(),
            uploadPhotos: () => document.getElementById('photo-upload').click(),
            recordVideo: () => toggleRecording(),
            resetTree: () => createTree()
        };

        const state = { isPlaying: false, leftHandOpen: 0, rightHandPinch: 0 };
        let scene, camera, renderer, controls, gui;
        let particleSystem, uniforms, snowSystem, starMesh, snowmanGroup, photoGroup;
        let audioCtx, analyser, dataArray = new Uint8Array(256), audioSource;
        let mediaRecorder, recordedChunks = [];
        let mediaPipeInitialized = false;
        
        // --- Shader (GLSL) ---
        const vertexShader = `
            uniform float uTime;
            uniform float uMixFactor;
            uniform float uBeat;
            uniform float uSize;
            attribute vec3 aTargetPos;
            attribute float aSize;
            attribute float aType; 
            attribute float aRandom;
            varying vec3 vColor;
            varying float vType;

            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main() {
                vType = aType;
                vec3 posA = position;
                vec3 posB = aTargetPos;
                
                if (uMixFactor < 0.85) {
                    float angle = uTime * 0.3 + posA.y * 0.1;
                    float c = cos(angle); float s = sin(angle);
                    posA.x = position.x * c - position.z * s;
                    posA.z = position.x * s + position.z * c;
                }
                vec3 finalPos = mix(posA, posB, uMixFactor);
                float beatStr = uBeat * (aType == 1.0 ? 2.5 : 0.8) * (1.0 + uMixFactor);
                finalPos += normalize(finalPos) * beatStr;

                vec3 baseColor;
                if (aType == 0.0) baseColor = vec3(0.05, 0.5 + aRandom*0.3, 0.1);
                else if (aType == 1.0) baseColor = aRandom > 0.5 ? vec3(1.0, 0.1, 0.1) : vec3(1.0, 0.8, 0.1);
                else baseColor = vec3(0.8, 0.9, 1.0);

                if (uMixFactor > 0.1) {
                    float hue = fract(uTime * 0.2 + aRandom + finalPos.y * 0.05);
                    vColor = mix(baseColor, hsv2rgb(vec3(hue, 0.8, 1.0)), uMixFactor * 0.8);
                } else {
                    vColor = baseColor;
                }

                float sizeMult = 1.0 + beatStr;
                if(aType == 2.0) sizeMult *= (sin(uTime * 10.0 + aRandom * 100.0) * 0.5 + 1.5);
                
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                gl_PointSize = aSize * uSize * sizeMult * (300.0 / -mvPosition.z);
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            varying float vType;
            void main() {
                vec2 circCoord = 2.0 * gl_PointCoord - 1.0;
                if (dot(circCoord, circCoord) > 1.0) discard;
                float dist = length(circCoord);
                float alpha = 1.0 - smoothstep(0.1, 1.0, dist);
                if(vType == 2.0) alpha += 0.5;
                gl_FragColor = vec4(vColor, alpha);
            }
        `;

        // --- Init ---
        function init() {
            try {
                // 1. åˆå§‹åŒ– 3D åœºæ™¯
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 20, 60);

                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true, 
                    preserveDrawingBuffer: true 
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.domElement.id = 'main-canvas';
                document.body.appendChild(renderer.domElement);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.autoRotate = true; 
                controls.autoRotateSpeed = 0.5;

                // 2. åˆ›å»ºç‰©ä½“
                createTree(); 
                createSnow(); 
                createStar(); 
                createSnowman(); 
                createPhotoSystem();
                initGUI();
                
                // 3. äº‹ä»¶ç»‘å®š
                window.addEventListener('resize', onResize);
                document.getElementById('music-upload').addEventListener('change', handleMusic);
                document.getElementById('photo-upload').addEventListener('change', handlePhotos);
                document.getElementById('start-btn').addEventListener('click', startExperience);
                document.getElementById('record-btn').addEventListener('click', toggleRecording);

                // 4. ç«‹å³å¯åŠ¨æ¸²æŸ“ (ä¸ç­‰å¾…AI)
                animate();
                document.getElementById('status-msg').innerText = "å›¾å½¢å¼•æ“å·²å¯åŠ¨. ç­‰å¾… AI åŠ è½½...";

                // 5. å¼‚æ­¥åŠ è½½ AIï¼ˆä½¿ç”¨åŠ¨æ€å¯¼å…¥é¿å…é˜»å¡ï¼‰
                loadMediaPipe();

            } catch (e) {
                logError("åˆå§‹åŒ–å¤±è´¥: " + e.message);
                document.getElementById('status-msg').innerText = "âŒ åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°";
            }
        }

        // --- åŠ¨æ€åŠ è½½ MediaPipe ---
        async function loadMediaPipe() {
            try {
                logInfo("å¼€å§‹åŠ è½½ MediaPipe...");
                
                // åŠ¨æ€åŠ è½½ MediaPipe è„šæœ¬
                await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');
                await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js');
                await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js');
                await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js');
                
                logInfo("MediaPipe è„šæœ¬åŠ è½½å®Œæˆï¼Œåˆå§‹åŒ–ä¸­...");
                await initMediaPipe();
                
                document.getElementById('status-msg').innerText = "âœ… AI å°±ç»ª! ç‚¹å‡»è¿›å…¥";
                logInfo("MediaPipe åˆå§‹åŒ–æˆåŠŸ");
            } catch (e) {
                console.warn("MediaPipe åŠ è½½å¤±è´¥:", e);
                document.getElementById('status-msg').innerText = "âš ï¸ AI åŠ è½½å¤±è´¥ (ç½‘ç»œé—®é¢˜), ä½†ä½ ä»å¯ä½¿ç”¨é¼ æ ‡äº’åŠ¨";
                logInfo("MediaPipe åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ¨¡å¼");
            }
        }

        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // --- æ ¸å¿ƒé€»è¾‘ ---
        function createTree() {
            if(particleSystem) {
                scene.remove(particleSystem);
                if(particleSystem.geometry) particleSystem.geometry.dispose();
                if(particleSystem.material) particleSystem.material.dispose();
            }
            
            const geo = new THREE.BufferGeometry();
            const pos = [], targets = [], sizes = [], types = [], rands = [];
            
            for (let i = 0; i < params.particleCount; i++) {
                const h = Math.random() * params.treeHeight;
                const r = params.treeRadius * (1 - h/params.treeHeight);
                const a = h * 5.0 + Math.random() * Math.PI * 2;
                pos.push(
                    Math.cos(a)*r + (Math.random()-0.5), 
                    h - params.treeHeight/2, 
                    Math.sin(a)*r + (Math.random()-0.5)
                );
                
                const phi = Math.acos(-1 + (2*i)/params.particleCount);
                const theta = Math.sqrt(params.particleCount*Math.PI)*phi;
                const rS = params.treeHeight*0.6;
                targets.push(
                    rS*Math.cos(theta)*Math.sin(phi), 
                    rS*Math.sin(theta)*Math.sin(phi), 
                    rS*Math.cos(phi)
                );
                
                const rnd = Math.random();
                types.push(rnd>0.93 ? 2 : (rnd>0.85 ? 1 : 0));
                sizes.push(Math.random()*0.5+0.5);
                rands.push(rnd);
            }
            
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('aTargetPos', new THREE.Float32BufferAttribute(targets, 3));
            geo.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('aType', new THREE.Float32BufferAttribute(types, 1));
            geo.setAttribute('aRandom', new THREE.Float32BufferAttribute(rands, 1));

            if (!uniforms) {
                uniforms = {
                    uTime: { value: 0 },
                    uMixFactor: { value: 0 },
                    uBeat: { value: 0 },
                    uSize: { value: params.particleSize }
                };
            } else {
                uniforms.uSize.value = params.particleSize;
            }
            
            const mat = new THREE.ShaderMaterial({
                uniforms,
                vertexShader,
                fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(geo, mat);
            scene.add(particleSystem);
        }

        function createSnow() {
            if(snowSystem) {
                scene.remove(snowSystem);
                if(snowSystem.geometry) snowSystem.geometry.dispose();
                if(snowSystem.material) snowSystem.material.dispose();
            }
            
            const geo = new THREE.BufferGeometry();
            const pos = [], rands = [];
            for(let i=0; i<params.snowCount; i++) {
                pos.push(
                    (Math.random()-0.5)*120, 
                    Math.random()*100 - 20, 
                    (Math.random()-0.5)*120
                );
                rands.push(Math.random());
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('aRand', new THREE.Float32BufferAttribute(rands, 1));
            
            const mat = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 0.4, 
                transparent: true, 
                opacity: 0.8,
                map: createCircleTexture()
            });
            
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        function createSnowman() {
            if(snowmanGroup) {
                scene.remove(snowmanGroup);
                snowmanGroup.traverse(child => {
                    if(child.geometry) child.geometry.dispose();
                    if(child.material) child.material.dispose();
                });
            }
            
            snowmanGroup = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.5});
            
            const b = new THREE.Mesh(new THREE.SphereGeometry(3,32,32), mat); 
            b.position.y = -params.treeHeight/2+3;
            
            const m = new THREE.Mesh(new THREE.SphereGeometry(2,32,32), mat); 
            m.position.y = b.position.y+4;
            
            const h = new THREE.Mesh(new THREE.SphereGeometry(1.4,32,32), mat); 
            h.position.y = m.position.y+2.8;
            
            const nose = new THREE.Mesh(
                new THREE.ConeGeometry(0.2,1,16), 
                new THREE.MeshStandardMaterial({color:0xff6600})
            );
            nose.rotation.x = Math.PI/2; 
            nose.position.z = 1.5; 
            h.add(nose);
            
            snowmanGroup.add(b, m, h); 
            snowmanGroup.position.set(15, 0, 15); 
            snowmanGroup.visible = params.showSnowman;
            scene.add(snowmanGroup);
        }

        function createStar() {
            if(starMesh) {
                scene.remove(starMesh);
                if(starMesh.geometry) starMesh.geometry.dispose();
                if(starMesh.material) starMesh.material.dispose();
            }
            
            const geo = new THREE.OctahedronGeometry(2, 0);
            starMesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:0xffffee, wireframe:true}));
            
            const pointLight = new THREE.PointLight(0xffffaa, 1, 30);
            starMesh.add(pointLight);
            
            scene.add(starMesh);
        }
        
        function createPhotoSystem() { 
            if(photoGroup) {
                scene.remove(photoGroup);
                photoGroup.traverse(child => {
                    if(child.material && child.material.map) child.material.map.dispose();
                    if(child.material) child.material.dispose();
                });
            }
            photoGroup = new THREE.Group(); 
            scene.add(photoGroup); 
        }
        
        function createCircleTexture() {
            const cvs = document.createElement('canvas'); 
            cvs.width = 32; 
            cvs.height = 32;
            const ctx = cvs.getContext('2d'); 
            ctx.fillStyle = '#fff'; 
            ctx.beginPath(); 
            ctx.arc(16, 16, 16, 0, Math.PI*2); 
            ctx.fill();
            return new THREE.CanvasTexture(cvs);
        }

        function handlePhotos(e) {
            const files = e.target.files; 
            if(!files.length) return;
            
            // æ¸…é™¤ç°æœ‰ç…§ç‰‡
            while(photoGroup.children.length) {
                const child = photoGroup.children[0];
                if(child.material && child.material.map) child.material.map.dispose();
                if(child.material) child.material.dispose();
                photoGroup.remove(child);
            }
            
            Array.from(files).forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = 256;
                        canvas.height = 256;
                        const ctx = canvas.getContext('2d');
                        
                        // åˆ›å»ºåœ†å½¢é®ç½©
                        ctx.beginPath();
                        ctx.arc(128, 128, 128, 0, Math.PI * 2);
                        ctx.clip();
                        
                        // ç»˜åˆ¶å›¾ç‰‡
                        ctx.drawImage(img, 0, 0, 256, 256);
                        
                        // æ·»åŠ ç™½è‰²è¾¹æ¡†
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.arc(128, 128, 128, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
                        
                        const h = Math.random() * params.treeHeight - params.treeHeight / 2;
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * params.treeRadius * 0.7;
                        const tPos = new THREE.Vector3(
                            Math.cos(angle) * radius, 
                            h, 
                            Math.sin(angle) * radius
                        );
                        
                        const t = (i / files.length) * Math.PI * 2;
                        const heartX = 16 * Math.pow(Math.sin(t), 3);
                        const heartY = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                        const hPos = new THREE.Vector3(heartX * 0.5, heartY * 0.5, 25);
                        
                        sprite.userData = { tPos, hPos };
                        sprite.position.copy(tPos);
                        sprite.scale.set(4, 4, 1);
                        photoGroup.add(sprite);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        function handleMusic(e) { 
            if(e.target.files.length) {
                initAudio(e.target.files[0]);
            }
        }
        
        function initAudio(file) {
            if(!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            if(audioSource) {
                try {
                    audioSource.stop();
                } catch(e) {}
            }
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const audioData = await audioCtx.decodeAudioData(e.target.result);
                    audioSource = audioCtx.createBufferSource();
                    audioSource.buffer = audioData;
                    
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 256;
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                    
                    audioSource.connect(analyser);
                    analyser.connect(audioCtx.destination);
                    audioSource.loop = true;
                    audioSource.start(0);
                    
                    logInfo("éŸ³é¢‘åŠ è½½æˆåŠŸ");
                } catch(err) {
                    logError("éŸ³é¢‘è§£ç å¤±è´¥: " + err.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // --- MediaPipe AI åˆå§‹åŒ– ---
        async function initMediaPipe() {
            if (typeof window.Hands === 'undefined') {
                throw new Error("Hands æœªå®šä¹‰ï¼Œè¯·æ£€æŸ¥ MediaPipe è„šæœ¬æ˜¯å¦åŠ è½½æˆåŠŸ");
            }
            
            const video = document.getElementById('input-video');
            const canvas = document.getElementById('video-preview');
            const ctx = canvas.getContext('2d');
            
            // æ£€æŸ¥æ‘„åƒå¤´æƒé™
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 320, height: 240 } 
                });
                video.srcObject = stream;
                await video.play();
            } catch(err) {
                logError("æ‘„åƒå¤´è®¿é—®å¤±è´¥: " + err.message);
                throw err;
            }
            
            const hands = new window.Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults((results) => {
                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶æ‘„åƒå¤´ç”»é¢
                if (results.image) {
                    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
                }
                
                // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹
                if (results.multiHandLandmarks) {
                    for (const landmarks of results.multiHandLandmarks) {
                        window.drawConnectors(ctx, landmarks, window.HAND_CONNECTIONS, {
                            color: '#00ff00',
                            lineWidth: 1
                        });
                        window.drawLandmarks(ctx, landmarks, {
                            color: '#ff0000',
                            lineWidth: 1,
                            radius: 2
                        });
                    }
                }
                ctx.restore();
                
                // è®¡ç®—æ‰‹éƒ¨çŠ¶æ€
                let leftHand = null;
                let rightHand = null;
                
                if (results.multiHandedness && results.multiHandLandmarks) {
                    for (let i = 0; i < results.multiHandedness.length; i++) {
                        if (results.multiHandedness[i].label === 'Left') {
                            leftHand = results.multiHandLandmarks[i];
                        } else if (results.multiHandedness[i].label === 'Right') {
                            rightHand = results.multiHandLandmarks[i];
                        }
                    }
                }
                
                // å·¦æ‰‹å¼ å¼€åº¦
                if (leftHand) {
                    const thumbTip = leftHand[4];
                    const middleTip = leftHand[12];
                    const distance = Math.hypot(
                        thumbTip.x - middleTip.x,
                        thumbTip.y - middleTip.y
                    );
                    state.leftHandOpen = THREE.MathUtils.clamp((distance - 0.1) * 5, 0, 1);
                } else {
                    state.leftHandOpen *= 0.9;
                }
                
                // å³æ‰‹æåˆ
                if (rightHand) {
                    const indexTip = rightHand[8];
                    const thumbTip = rightHand[4];
                    const distance = Math.hypot(
                        indexTip.x - thumbTip.x,
                        indexTip.y - thumbTip.y
                    );
                    state.rightHandPinch = distance < 0.05 ? 1 : 0;
                } else {
                    state.rightHandPinch = 0;
                }
            });
            
            // ä½¿ç”¨ requestAnimationFrame å¾ªç¯å¤„ç†è§†é¢‘å¸§
            async function processVideoFrame() {
                if (video.readyState >= 2) {
                    try {
                        await hands.send({ image: video });
                    } catch(e) {
                        console.warn("MediaPipe å¤„ç†å¸§å¤±è´¥:", e);
                    }
                }
                requestAnimationFrame(processVideoFrame);
            }
            
            mediaPipeInitialized = true;
            processVideoFrame();
            
            // æ˜¾ç¤ºå½•åˆ¶æŒ‰é’®
            if (MediaRecorder && MediaRecorder.isTypeSupported('video/webm')) {
                document.getElementById('record-btn').style.display = 'flex';
            }
        }

        function toggleRecording() {
            const btn = document.getElementById('record-btn');
            
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                btn.classList.remove('recording');
            } else {
                try {
                    const stream = renderer.domElement.captureStream(30);
                    recordedChunks = [];
                    
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm; codecs=vp9'
                    });
                    
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            recordedChunks.push(e.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(recordedChunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        
                        const a = document.createElement('a');
                        a.style.display = 'none';
                        a.href = url;
                        a.download = `christmas_${Date.now()}.webm`;
                        
                        document.body.appendChild(a);
                        a.click();
                        
                        setTimeout(() => {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }, 100);
                    };
                    
                    mediaRecorder.start();
                    btn.classList.add('recording');
                } catch(err) {
                    logError("å½•åˆ¶å¤±è´¥: " + err.message);
                }
            }
        }

        function initGUI() {
            gui = new GUI({ title: 'Super Console' });
            gui.domElement.style.marginTop = '10px';
            gui.domElement.style.position = 'absolute';
            gui.domElement.style.top = '10px';
            gui.domElement.style.right = '10px';
            
            const treeFolder = gui.addFolder('Tree');
            treeFolder.add(params, 'treeHeight', 10, 60).onChange(() => createTree());
            treeFolder.add(params, 'particleCount', 1000, 20000).step(100).onChange(() => createTree());
            treeFolder.add(params, 'particleSize', 0.1, 5).onChange(v => {
                if (uniforms) uniforms.uSize.value = v;
            });
            treeFolder.open();
            
            const envFolder = gui.addFolder('Environment');
            envFolder.add(params, 'bgStyle', ['Deep Space', 'Aurora', 'Pitch Black']).onChange(updateBG);
            envFolder.add(params, 'snowSpeed', 0, 5);
            envFolder.add(params, 'windStrength', 0, 2);
            envFolder.add(params, 'showSnowman').onChange(v => {
                if (snowmanGroup) snowmanGroup.visible = v;
            });
            envFolder.open();
            
            const actionFolder = gui.addFolder('Actions');
            actionFolder.add(params, 'uploadMusic');
            actionFolder.add(params, 'uploadPhotos');
            actionFolder.add(params, 'recordVideo');
            actionFolder.add(params, 'resetTree');
            actionFolder.open();
            
            updateBG('Deep Space');
        }
        
        function updateBG(style) {
            if (style === 'Pitch Black') {
                document.body.style.background = '#000';
            } else if (style === 'Aurora') {
                document.body.style.background = 'linear-gradient(to bottom, #000428, #004e92)';
            } else if (style === 'Deep Space') {
                document.body.style.background = 'radial-gradient(circle at center, #1a2a6c, #b21f1f, #fdbb2d)';
            }
        }
        
        function startExperience() {
            const startScreen = document.getElementById('start-screen');
            startScreen.style.opacity = '0';
            
            setTimeout(() => {
                startScreen.style.display = 'none';
            }, 500);
            
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆæµè§ˆå™¨è¦æ±‚ç”¨æˆ·äº¤äº’åï¼‰
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            state.isPlaying = true;
        }
        
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            
            // éŸ³é¢‘åˆ†æ
            let beat = 0;
            if (analyser && dataArray) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < 10; i++) {
                    sum += dataArray[i];
                }
                beat = (sum / 10) / 255.0 * params.audioSens;
            }
            
            // æ›´æ–°ç²’å­ç³»ç»Ÿ
            if (uniforms) {
                uniforms.uTime.value = time;
                uniforms.uBeat.value = beat;
                
                // å¹³æ»‘è¿‡æ¸¡æ··åˆå› å­
                uniforms.uMixFactor.value += (state.leftHandOpen - uniforms.uMixFactor.value) * params.reactionSpeed;
            }
            
            // æ›´æ–°æ˜Ÿæ˜Ÿ
            if (starMesh) {
                starMesh.rotation.y = time;
                if (uniforms) {
                    const heightFactor = 1 - uniforms.uMixFactor.value * 0.4;
                    starMesh.position.y = (params.treeHeight / 2 + 2) * heightFactor;
                }
                starMesh.scale.setScalar(1 + beat * 0.5);
            }
            
            // æ›´æ–°é›ªèŠ±
            if (snowSystem) {
                const positions = snowSystem.geometry.attributes.position.array;
                const randoms = snowSystem.geometry.attributes.aRand.array;
                
                for (let i = 0; i < params.snowCount; i++) {
                    const idx = i * 3;
                    
                    // ä¸‹è½
                    positions[idx + 1] -= params.snowSpeed * (0.1 + beat * 0.2);
                    
                    // é£åŠ›æ¼‚ç§»
                    positions[idx] += Math.sin(time + positions[idx + 1] * 0.05) * params.windStrength * 0.1;
                    
                    // å¾ªç¯é›ªèŠ±
                    if (positions[idx + 1] < -params.treeHeight) {
                        positions[idx + 1] = params.treeHeight + 10;
                        positions[idx] = (Math.random() - 0.5) * 100;
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // æ›´æ–°ç…§ç‰‡å¢™
            if (photoGroup && photoGroup.children.length > 0) {
                const targetFactor = state.rightHandPinch;
                
                photoGroup.children.forEach(sprite => {
                    const targetPos = targetFactor > 0.5 ? sprite.userData.hPos : sprite.userData.tPos;
                    sprite.position.lerp(targetPos, 0.1);
                    
                    if (beat > 0.1) {
                        sprite.scale.setScalar(4 + beat * 2);
                    } else {
                        sprite.scale.setScalar(4);
                    }
                });
                
                // æ ¹æ®æ‰‹åŠ¿æ§åˆ¶æ—‹è½¬
                if (targetFactor < 0.5) {
                    photoGroup.rotation.y = -controls.getAzimuthalAngle();
                } else {
                    photoGroup.rotation.y = 0;
                }
            }
            
            // æ›´æ–°æ§åˆ¶å™¨
            controls.update();
            
            // æ¸²æŸ“
            renderer.render(scene, camera);
        }

        // å¯åŠ¨åº”ç”¨
        init();
    </script>
</body>
</html>