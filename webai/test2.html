<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手势控制粒子特效</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
        }
        
        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        
        #status {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00ff88;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid #00ff88;
            z-index: 100;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            z-index: 100;
        }
        
        button {
            background: #00ff88;
            color: black;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-left: 10px;
        }
        
        button:hover {
            background: #00cc66;
        }
        
        #videoPreview {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 5px;
            border: 2px solid #00ff88;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="status">初始化中...</div>
    <div id="controls">
        <button id="togglePreview">显示摄像头</button>
        <button id="changeColor">切换颜色</button>
    </div>
    <video id="videoPreview" autoplay playsinline></video>

    <script type="module">
        // 导入Three.js
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        
        // 配置摄像头参数（使用你的摄像头参数）
        const CAMERA_SETTINGS = {
            width: 1280,
            height: 720,
            frameRate: 30,
            facingMode: 'user'
        };
        
        // 配置粒子系统
        const CONFIG = {
            particleCount: 10000,
            particleSize: 0.1,
            colors: [
                '#00ff88',  // 绿色
                '#0088ff',  // 蓝色
                '#ff0088',  // 粉色
                '#ffff00',  // 黄色
                '#ff8800'   // 橙色
            ],
            shapes: ['sphere', 'cube', 'ring', 'wave', 'vortex']
        };
        
        // 全局变量
        let scene, camera, renderer, particles, particleMaterial;
        let videoStream = null;
        let currentColorIndex = 0;
        let currentShapeIndex = 0;
        let handPosition = { x: 0, y: 0, z: 0 };
        let handScale = 1.0;
        let handActive = false;
        
        // 初始化Three.js
        function initThreeJS() {
            // 创建场景
            scene = new THREE.Scene();
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 添加环境光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // 添加点光源
            const pointLight = new THREE.PointLight(CONFIG.colors[0], 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            // 创建粒子系统
            createParticles();
            
            updateStatus("3D场景已就绪");
        }
        
        // 创建粒子系统
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            
            // 初始化粒子位置和颜色
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                
                // 随机位置
                positions[i3] = (Math.random() - 0.5) * 20;
                positions[i3 + 1] = (Math.random() - 0.5) * 20;
                positions[i3 + 2] = (Math.random() - 0.5) * 20;
                
                // 颜色
                const color = new THREE.Color(CONFIG.colors[currentColorIndex]);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // 创建粒子材质
            particleMaterial = new THREE.PointsMaterial({
                size: CONFIG.particleSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            // 创建粒子系统
            particles = new THREE.Points(geometry, particleMaterial);
            scene.add(particles);
        }
        
        // 更新粒子颜色
        function updateParticleColor() {
            const colors = particles.geometry.attributes.color.array;
            const color = new THREE.Color(CONFIG.colors[currentColorIndex]);
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            
            particles.geometry.attributes.color.needsUpdate = true;
        }
        
        // 更新粒子形状
        function updateParticleShape() {
            const positions = particles.geometry.attributes.position.array;
            const shape = CONFIG.shapes[currentShapeIndex];
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                let x, y, z;
                
                switch(shape) {
                    case 'sphere':
                        // 球体
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        const radius = 8;
                        x = radius * Math.sin(phi) * Math.cos(theta);
                        y = radius * Math.sin(phi) * Math.sin(theta);
                        z = radius * Math.cos(phi);
                        break;
                        
                    case 'cube':
                        // 立方体
                        x = (Math.random() - 0.5) * 10;
                        y = (Math.random() - 0.5) * 10;
                        z = (Math.random() - 0.5) * 10;
                        break;
                        
                    case 'ring':
                        // 圆环
                        const angle = Math.random() * Math.PI * 2;
                        const ringRadius = 6;
                        x = Math.cos(angle) * ringRadius;
                        y = (Math.random() - 0.5) * 2;
                        z = Math.sin(angle) * ringRadius;
                        break;
                        
                    case 'wave':
                        // 波形
                        const waveX = (i / CONFIG.particleCount) * Math.PI * 4;
                        x = waveX - Math.PI * 2;
                        y = Math.sin(waveX) * 3;
                        z = (Math.random() - 0.5) * 6;
                        break;
                        
                    case 'vortex':
                        // 漩涡
                        const vortexT = (i / CONFIG.particleCount) * Math.PI * 6;
                        const vortexR = 4;
                        x = Math.cos(vortexT) * vortexR;
                        y = vortexT;
                        z = Math.sin(vortexT) * vortexR;
                        break;
                }
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
        }
        
        // 初始化摄像头
        async function initCamera() {
            try {
                updateStatus("正在启动摄像头...");
                
                // 请求摄像头访问
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: CAMERA_SETTINGS.width },
                        height: { ideal: CAMERA_SETTINGS.height },
                        frameRate: { ideal: CAMERA_SETTINGS.frameRate },
                        facingMode: CAMERA_SETTINGS.facingMode
                    }
                });
                
                // 设置预览视频
                const videoPreview = document.getElementById('videoPreview');
                videoPreview.srcObject = videoStream;
                
                updateStatus("✅ 摄像头已就绪！移动手部控制粒子");
                
                // 开始手部检测模拟
                startHandTracking();
                
            } catch (error) {
                console.error('摄像头错误:', error);
                updateStatus("❌ 摄像头错误，使用鼠标控制");
                
                // 使用鼠标控制作为备选
                setupMouseControl();
            }
        }
        
        // 模拟手部跟踪
        function startHandTracking() {
            // 简单的手部位置模拟
            setInterval(() => {
                if (videoStream) {
                    // 模拟基于摄像头的手部位置
                    const time = Date.now() * 0.001;
                    
                    // 随机手部位置（实际项目中应该使用MediaPipe）
                    handPosition.x = Math.sin(time) * 5;
                    handPosition.y = Math.cos(time * 0.7) * 3;
                    handPosition.z = Math.sin(time * 0.5) * 2;
                    
                    // 随机缩放
                    handScale = 0.8 + Math.sin(time * 0.3) * 0.4;
                    
                    handActive = true;
                }
            }, 100);
        }
        
        // 鼠标控制（备用）
        function setupMouseControl() {
            document.addEventListener('mousemove', (e) => {
                handPosition.x = (e.clientX / window.innerWidth) * 10 - 5;
                handPosition.y = -(e.clientY / window.innerHeight) * 6 + 3;
                handPosition.z = Math.sin(Date.now() * 0.001) * 2;
                handScale = 1.0;
                handActive = true;
            });
            
            document.addEventListener('mouseleave', () => {
                handActive = false;
            });
            
            document.addEventListener('click', () => {
                currentShapeIndex = (currentShapeIndex + 1) % CONFIG.shapes.length;
                updateParticleShape();
            });
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // 更新粒子位置（基于手部位置）
            if (particles && handActive) {
                const positions = particles.geometry.attributes.position.array;
                
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const i3 = i * 3;
                    
                    // 获取原始目标位置（从几何体复制）
                    const originalX = positions[i3];
                    const originalY = positions[i3 + 1];
                    const originalZ = positions[i3 + 2];
                    
                    // 计算手部影响
                    const handInfluence = 0.05;
                    const distance = Math.sqrt(
                        Math.pow(originalX - handPosition.x, 2) +
                        Math.pow(originalY - handPosition.y, 2) +
                        Math.pow(originalZ - handPosition.z, 2)
                    );
                    
                    // 手部附近的粒子被推开
                    const repelStrength = 0.1;
                    if (distance < 3) {
                        positions[i3] += (originalX - handPosition.x) * repelStrength;
                        positions[i3 + 1] += (originalY - handPosition.y) * repelStrength;
                        positions[i3 + 2] += (originalZ - handPosition.z) * repelStrength;
                    }
                    
                    // 应用手部缩放
                    positions[i3] = originalX * handScale;
                    positions[i3 + 1] = originalY * handScale;
                    positions[i3 + 2] = originalZ * handScale;
                    
                    // 添加轻微浮动
                    positions[i3] += Math.sin(time + i * 0.01) * 0.02;
                    positions[i3 + 1] += Math.cos(time * 0.7 + i * 0.01) * 0.02;
                    positions[i3 + 2] += Math.sin(time * 0.5 + i * 0.01) * 0.02;
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                
                // 旋转相机（如果没有手部交互时）
                if (!handActive) {
                    camera.position.x = Math.sin(time * 0.2) * 15;
                    camera.position.z = Math.cos(time * 0.2) * 15;
                    camera.lookAt(0, 0, 0);
                }
            }
            
            // 渲染
            renderer.render(scene, camera);
        }
        
        // 更新状态显示
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // 初始化应用
        async function initApp() {
            try {
                // 初始化Three.js
                initThreeJS();
                
                // 初始化摄像头
                await initCamera();
                
                // 开始动画
                animate();
                
                // 设置UI事件
                document.getElementById('togglePreview').addEventListener('click', () => {
                    const preview = document.getElementById('videoPreview');
                    preview.style.display = preview.style.display === 'none' ? 'block' : 'none';
                });
                
                document.getElementById('changeColor').addEventListener('click', () => {
                    currentColorIndex = (currentColorIndex + 1) % CONFIG.colors.length;
                    updateParticleColor();
                });
                
                // 键盘快捷键
                document.addEventListener('keydown', (e) => {
                    switch(e.key.toLowerCase()) {
                        case ' ':
                            // 空格键切换形状
                            currentShapeIndex = (currentShapeIndex + 1) % CONFIG.shapes.length;
                            updateParticleShape();
                            break;
                        case 'c':
                            // C键切换颜色
                            currentColorIndex = (currentColorIndex + 1) % CONFIG.colors.length;
                            updateParticleColor();
                            break;
                        case 'r':
                            // R键重新开始
                            location.reload();
                            break;
                    }
                });
                
                // 窗口大小调整
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
            } catch (error) {
                console.error('初始化错误:', error);
                updateStatus("❌ 初始化错误: " + error.message);
            }
        }
        
        // 页面加载后启动
        window.addEventListener('load', initApp);
    </script>
</body>
</html>