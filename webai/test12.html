<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ¢¦å¹»äº’åŠ¨éŸ³ä¹åœ£è¯æ ‘</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; outline: none; }
        
        #debug-console {
            position: absolute; top: 0; left: 0; width: 100%; max-height: 200px;
            background: rgba(50, 0, 0, 0.8); color: #ffcccc; 
            font-family: monospace; font-size: 12px; 
            overflow-y: auto; pointer-events: none; z-index: 9999;
            padding: 10px; display: none;
        }

        #start-screen {
            position: absolute; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; pointer-events: auto; backdrop-filter: blur(10px); z-index: 999;
            transition: opacity 0.5s;
        }
        
        .hero-btn {
            padding: 15px 50px; font-size: 1.2rem; font-weight: bold;
            background: linear-gradient(135deg, #ff3366, #ff6b6b);
            border: none; border-radius: 50px; color: white;
            cursor: pointer; box-shadow: 0 0 30px rgba(255, 51, 102, 0.5);
            transition: all 0.3s; margin-top: 30px; letter-spacing: 2px;
        }
        .hero-btn:hover { transform: scale(1.1); box-shadow: 0 0 50px rgba(255, 51, 102, 0.8); }
        .hero-btn:disabled { background: #666; cursor: not-allowed; transform: none; box-shadow: none; }

        #record-btn {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 60px; height: 60px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255,255,255,0.5);
            cursor: pointer; pointer-events: auto; display: none;
            justify-content: center; align-items: center; transition: all 0.3s; z-index: 100;
        }
        #record-btn .inner { width: 25px; height: 25px; background: #ff3366; border-radius: 50%; transition: all 0.3s; }
        #record-btn.recording { border-color: #ff3366; background: rgba(255, 51, 102, 0.1); }
        #record-btn.recording .inner { transform: scale(0.6); border-radius: 4px; } 

        #video-preview {
            position: absolute; bottom: 20px; left: 20px; width: 120px; height: 90px;
            border-radius: 8px; opacity: 0.6; transform: scaleX(-1); border: 1px solid rgba(255,255,255,0.3);
            pointer-events: auto; transition: opacity 0.3s; z-index: 90; background: #000;
        }
        
        .loading-text { font-family: monospace; color: #00ffcc; margin-top: 10px; font-size: 0.9rem; text-align: center;}
        #file-inputs { display: none; }
        
        .loader {
            width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #ff3366;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="debug-console"></div>

    <div id="file-inputs">
        <input type="file" id="music-upload" accept="audio/*">
        <input type="file" id="photo-upload" accept="image/*" multiple>
    </div>
    
    <video id="input-video" style="display:none;" playsinline></video>
    
    <div id="start-screen">
        <h1 style="text-shadow: 0 0 30px #ff3366; margin-bottom: 0;">ğŸ„ Christmas Tree V3.0</h1>
        <p style="color: #aaa; font-size: 0.9rem;">Engineer Edition â€¢ Stable</p>
        
        <div style="text-align: left; background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin: 20px; max-width: 400px;">
            <p>âœ‹ <b>å·¦æ‰‹:</b> å¼ å¼€æ§åˆ¶çˆ†ç‚¸ (å˜è‰²)</p>
            <p>ğŸ«° <b>å³æ‰‹:</b> æåˆå¬å”¤ç…§ç‰‡å¢™</p>
            <p style="font-size: 0.8rem; color: #ff6b6b;" id="status-msg">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...</p>
        </div>

        <button id="start-btn" class="hero-btn">è¿›å…¥ç³»ç»Ÿ</button>
        <div style="margin-top: 20px; font-size: 0.8rem; color: #aaa;">
            å¦‚æœAIåŠ è½½å¤±è´¥ï¼Œæ‚¨ä»å¯ä½¿ç”¨é¼ æ ‡æ§åˆ¶
        </div>
    </div>

    <div id="record-btn" title="å½•åˆ¶è§†é¢‘"><div class="inner"></div></div>
    <canvas id="video-preview"></canvas>

    <!-- æ‰‹åŠ¨åŠ è½½MediaPipeè„šæœ¬ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import GUI from 'https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.module.min.js';

        // --- å…¨å±€å˜é‡ ---
        const params = {
            treeHeight: 35, treeRadius: 12, particleCount: 5000, particleSize: 1.5,
            snowCount: 800, snowSpeed: 1.0, windStrength: 0.5, bgStyle: 'Deep Space',
            audioSens: 1.5, reactionSpeed: 0.1, showSnowman: true,
            uploadMusic: () => document.getElementById('music-upload').click(),
            uploadPhotos: () => document.getElementById('photo-upload').click(),
            recordVideo: () => toggleRecording(),
            resetTree: () => createTree()
        };

        const state = { isPlaying: false, leftHandOpen: 0, rightHandPinch: 0 };
        let scene, camera, renderer, controls, gui;
        let particleSystem, uniforms, snowSystem, starMesh, snowmanGroup, photoGroup;
        let audioCtx, analyser, dataArray = new Uint8Array(256), audioSource;
        let mediaRecorder, recordedChunks = [];
        let handsModel = null;
        
        // --- è°ƒè¯•å·¥å…· ---
        const debugConsole = document.getElementById('debug-console');
        function logError(msg) {
            debugConsole.style.display = 'block';
            debugConsole.innerHTML += `<div>âŒ ${new Date().toLocaleTimeString()}: ${msg}</div>`;
            console.error(msg);
        }
        function logInfo(msg) {
            console.log(msg);
            document.getElementById('status-msg').innerText = msg;
        }

        // --- Shader (GLSL) ---
        const vertexShader = `
            uniform float uTime;
            uniform float uMixFactor;
            uniform float uBeat;
            uniform float uSize;
            attribute vec3 aTargetPos;
            attribute float aSize;
            attribute float aType; 
            attribute float aRandom;
            varying vec3 vColor;
            varying float vType;

            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main() {
                vType = aType;
                vec3 posA = position;
                vec3 posB = aTargetPos;
                
                if (uMixFactor < 0.85) {
                    float angle = uTime * 0.3 + posA.y * 0.1;
                    float c = cos(angle); float s = sin(angle);
                    posA.x = position.x * c - position.z * s;
                    posA.z = position.x * s + position.z * c;
                }
                vec3 finalPos = mix(posA, posB, uMixFactor);
                float beatStr = uBeat * (aType == 1.0 ? 2.5 : 0.8) * (1.0 + uMixFactor);
                finalPos += normalize(finalPos) * beatStr;

                vec3 baseColor;
                if (aType == 0.0) baseColor = vec3(0.05, 0.5 + aRandom*0.3, 0.1);
                else if (aType == 1.0) baseColor = aRandom > 0.5 ? vec3(1.0, 0.1, 0.1) : vec3(1.0, 0.8, 0.1);
                else baseColor = vec3(0.8, 0.9, 1.0);

                if (uMixFactor > 0.1) {
                    float hue = fract(uTime * 0.2 + aRandom + finalPos.y * 0.05);
                    vColor = mix(baseColor, hsv2rgb(vec3(hue, 0.8, 1.0)), uMixFactor * 0.8);
                } else {
                    vColor = baseColor;
                }

                float sizeMult = 1.0 + beatStr;
                if(aType == 2.0) sizeMult *= (sin(uTime * 10.0 + aRandom * 100.0) * 0.5 + 1.5);
                
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                gl_PointSize = aSize * uSize * sizeMult * (300.0 / -mvPosition.z);
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            varying float vType;
            void main() {
                vec2 circCoord = 2.0 * gl_PointCoord - 1.0;
                if (dot(circCoord, circCoord) > 1.0) discard;
                float dist = length(circCoord);
                float alpha = 1.0 - smoothstep(0.1, 1.0, dist);
                if(vType == 2.0) alpha += 0.5;
                gl_FragColor = vec4(vColor, alpha);
            }
        `;

        // --- åˆå§‹åŒ–å‡½æ•° ---
        async function init() {
            try {
                logInfo("æ­£åœ¨åˆå§‹åŒ–3Då¼•æ“...");
                
                // 1. ç«‹å³åˆ›å»º3Dåœºæ™¯
                createScene();
                
                // 2. åˆå§‹åŒ–UIäº‹ä»¶
                initUIEvents();
                
                // 3. ç«‹å³å¼€å§‹æ¸²æŸ“å¾ªç¯
                animate();
                
                logInfo("3Då¼•æ“å·²å°±ç»ªï¼");
                
                // 4. å¼‚æ­¥åŠ è½½AIï¼ˆä¸é˜»å¡ä¸»æµç¨‹ï¼‰
                setTimeout(initAI, 100);
                
            } catch (e) {
                logError("åˆå§‹åŒ–å¤±è´¥: " + e.message);
                logInfo("åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•");
            }
        }

        function createScene() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 60);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true, 
                preserveDrawingBuffer: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
            
            // åˆ›å»ºæ§åˆ¶å™¨
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true; 
            controls.autoRotateSpeed = 0.3;
            
            // åˆ›å»ºæ‰€æœ‰ç‰©ä½“
            createTree();
            createSnow();
            createStar();
            createSnowman();
            createPhotoSystem();
            
            // åˆ›å»ºGUI
            createGUI();
            
            // è®¾ç½®èƒŒæ™¯
            updateBG('Deep Space');
        }

        function initUIEvents() {
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // å¼€å§‹æŒ‰é’®
            document.getElementById('start-btn').addEventListener('click', startExperience);
            
            // æ–‡ä»¶ä¸Šä¼ 
            document.getElementById('music-upload').addEventListener('change', handleMusic);
            document.getElementById('photo-upload').addEventListener('change', handlePhotos);
            
            // å½•åˆ¶æŒ‰é’®
            document.getElementById('record-btn').addEventListener('click', toggleRecording);
        }

        async function initAI() {
            try {
                logInfo("æ­£åœ¨åŠ è½½AIæ¨¡å‹...");
                
                if (typeof Hands === 'undefined') {
                    throw new Error("MediaPipeåº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥");
                }
                
                const video = document.getElementById('input-video');
                const canvas = document.getElementById('video-preview');
                
                // æ£€æŸ¥æ‘„åƒå¤´æƒé™
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 320 },
                            height: { ideal: 240 },
                            facingMode: 'user' 
                        } 
                    });
                    video.srcObject = stream;
                    await video.play();
                    logInfo("æ‘„åƒå¤´å·²å¯ç”¨");
                } catch(err) {
                    logInfo("æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»ï¼Œå°†ä½¿ç”¨é¼ æ ‡æ§åˆ¶");
                    console.warn("æ‘„åƒå¤´é”™è¯¯:", err);
                    return;
                }
                
                // åˆ›å»ºæ‰‹éƒ¨æ£€æµ‹æ¨¡å‹
                handsModel = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                handsModel.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                handsModel.onResults(onHandResults);
                
                // å¯åŠ¨æ‘„åƒå¤´å¤„ç†å¾ªç¯
                async function processVideoFrame() {
                    if (video.readyState >= 2) {
                        await handsModel.send({ image: video });
                    }
                    requestAnimationFrame(processVideoFrame);
                }
                
                processVideoFrame();
                logInfo("âœ… AIæ¨¡å‹åŠ è½½å®Œæˆ");
                
                // æ˜¾ç¤ºå½•åˆ¶æŒ‰é’®
                if (MediaRecorder && MediaRecorder.isTypeSupported('video/webm')) {
                    document.getElementById('record-btn').style.display = 'flex';
                }
                
            } catch (error) {
                console.warn("AIåˆå§‹åŒ–å¤±è´¥:", error);
                logInfo("âš ï¸ AIåŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨é¼ æ ‡æ§åˆ¶");
            }
        }

        function onHandResults(results) {
            const canvas = document.getElementById('video-preview');
            const ctx = canvas.getContext('2d');
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶è§†é¢‘å¸§
            if (results.image) {
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            }
            
            // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {
                        color: '#00FF00',
                        lineWidth: 2
                    });
                    drawLandmarks(ctx, landmarks, {
                        color: '#FF0000',
                        lineWidth: 1
                    });
                }
            }
            
            // åˆ†ææ‰‹éƒ¨å§¿æ€
            if (results.multiHandedness && results.multiHandLandmarks) {
                let leftHand = null;
                let rightHand = null;
                
                for (let i = 0; i < results.multiHandedness.length; i++) {
                    const hand = results.multiHandedness[i];
                    const landmarks = results.multiHandLandmarks[i];
                    
                    if (hand.label === 'Left') {
                        leftHand = landmarks;
                    } else if (hand.label === 'Right') {
                        rightHand = landmarks;
                    }
                }
                
                // å·¦æ‰‹å¼ å¼€åº¦
                if (leftHand) {
                    const thumbTip = leftHand[4];
                    const middleTip = leftHand[12];
                    const distance = Math.sqrt(
                        Math.pow(thumbTip.x - middleTip.x, 2) + 
                        Math.pow(thumbTip.y - middleTip.y, 2)
                    );
                    state.leftHandOpen = Math.min(Math.max((distance - 0.1) * 4, 0), 1);
                } else {
                    state.leftHandOpen *= 0.95; // å¹³æ»‘è¡°å‡
                }
                
                // å³æ‰‹æåˆ
                if (rightHand) {
                    const thumbTip = rightHand[4];
                    const indexTip = rightHand[8];
                    const distance = Math.sqrt(
                        Math.pow(thumbTip.x - indexTip.x, 2) + 
                        Math.pow(thumbTip.y - indexTip.y, 2)
                    );
                    state.rightHandPinch = distance < 0.05 ? 1 : 0;
                } else {
                    state.rightHandPinch = 0;
                }
            }
        }

        // --- æ ¸å¿ƒå›¾å½¢å‡½æ•° ---
        function createTree() {
            // æ¸…ç†æ—§çš„ç²’å­ç³»ç»Ÿ
            if (particleSystem) {
                scene.remove(particleSystem);
                if (particleSystem.geometry) particleSystem.geometry.dispose();
                if (particleSystem.material) particleSystem.material.dispose();
            }
            
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const targetPositions = [];
            const sizes = [];
            const types = [];
            const randoms = [];
            
            for (let i = 0; i < params.particleCount; i++) {
                const height = Math.random() * params.treeHeight;
                const radius = params.treeRadius * (1 - height / params.treeHeight);
                const angle = height * 5 + Math.random() * Math.PI * 2;
                
                positions.push(
                    Math.cos(angle) * radius + (Math.random() - 0.5),
                    height - params.treeHeight / 2,
                    Math.sin(angle) * radius + (Math.random() - 0.5)
                );
                
                // çƒä½“ç›®æ ‡ä½ç½®ï¼ˆçˆ†ç‚¸æ•ˆæœï¼‰
                const phi = Math.acos(-1 + (2 * i) / params.particleCount);
                const theta = Math.sqrt(params.particleCount * Math.PI) * phi;
                const sphereRadius = params.treeHeight * 0.5;
                
                targetPositions.push(
                    sphereRadius * Math.sin(phi) * Math.cos(theta),
                    sphereRadius * Math.sin(phi) * Math.sin(theta),
                    sphereRadius * Math.cos(phi)
                );
                
                const rand = Math.random();
                // 0: ç»¿å¶, 1: è£…é¥°çƒ, 2: ç¯
                types.push(rand > 0.95 ? 2 : (rand > 0.85 ? 1 : 0));
                sizes.push(Math.random() * 0.5 + 0.5);
                randoms.push(rand);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aTargetPos', new THREE.Float32BufferAttribute(targetPositions, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('aType', new THREE.Float32BufferAttribute(types, 1));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            
            // åˆå§‹åŒ–uniforms
            uniforms = {
                uTime: { value: 0 },
                uMixFactor: { value: 0 },
                uBeat: { value: 0 },
                uSize: { value: params.particleSize }
            };
            
            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function createSnow() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const randoms = [];
            
            for (let i = 0; i < params.snowCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 100,
                    Math.random() * 80 - 10,
                    (Math.random() - 0.5) * 100
                );
                randoms.push(Math.random());
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aRand', new THREE.Float32BufferAttribute(randoms, 1));
            
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.3,
                transparent: true,
                opacity: 0.7
            });
            
            snowSystem = new THREE.Points(geometry, material);
            scene.add(snowSystem);
        }

        function createStar() {
            const geometry = new THREE.OctahedronGeometry(3, 0);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffee, 
                wireframe: true 
            });
            starMesh = new THREE.Mesh(geometry, material);
            
            const light = new THREE.PointLight(0xffffaa, 0.8, 50);
            starMesh.add(light);
            
            scene.add(starMesh);
        }

        function createSnowman() {
            snowmanGroup = new THREE.Group();
            
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                roughness: 0.7 
            });
            
            // åº•éƒ¨å¤§é›ªçƒ
            const bottom = new THREE.Mesh(
                new THREE.SphereGeometry(3, 32, 32),
                material
            );
            bottom.position.y = -params.treeHeight / 2 + 3;
            
            // ä¸­éƒ¨é›ªçƒ
            const middle = new THREE.Mesh(
                new THREE.SphereGeometry(2, 32, 32),
                material
            );
            middle.position.y = bottom.position.y + 4;
            
            // å¤´éƒ¨é›ªçƒ
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 32, 32),
                material
            );
            head.position.y = middle.position.y + 3;
            
            // èƒ¡èåœé¼»å­
            const nose = new THREE.Mesh(
                new THREE.ConeGeometry(0.2, 1, 8),
                new THREE.MeshBasicMaterial({ color: 0xff6600 })
            );
            nose.rotation.z = Math.PI / 2;
            nose.position.x = 1;
            head.add(nose);
            
            snowmanGroup.add(bottom, middle, head);
            snowmanGroup.position.set(20, 0, 15);
            snowmanGroup.visible = params.showSnowman;
            scene.add(snowmanGroup);
        }

        function createPhotoSystem() {
            photoGroup = new THREE.Group();
            scene.add(photoGroup);
        }

        function createGUI() {
            gui = new GUI({ title: 'æ§åˆ¶é¢æ¿', width: 300 });
            
            const treeFolder = gui.addFolder('åœ£è¯æ ‘è®¾ç½®');
            treeFolder.add(params, 'treeHeight', 20, 60).onChange(() => createTree());
            treeFolder.add(params, 'particleCount', 1000, 10000).step(500).onChange(() => createTree());
            treeFolder.add(params, 'particleSize', 0.5, 3).onChange(v => {
                if (uniforms) uniforms.uSize.value = v;
            });
            treeFolder.open();
            
            const envFolder = gui.addFolder('ç¯å¢ƒè®¾ç½®');
            envFolder.add(params, 'bgStyle', ['Deep Space', 'Aurora', 'Pitch Black']).onChange(updateBG);
            envFolder.add(params, 'snowSpeed', 0, 3);
            envFolder.add(params, 'windStrength', 0, 2);
            envFolder.add(params, 'showSnowman').onChange(v => {
                if (snowmanGroup) snowmanGroup.visible = v;
            });
            envFolder.open();
            
            const audioFolder = gui.addFolder('éŸ³é¢‘è®¾ç½®');
            audioFolder.add(params, 'audioSens', 0.5, 3).step(0.1);
            audioFolder.add(params, 'reactionSpeed', 0.05, 0.5).step(0.05);
            
            const actionFolder = gui.addFolder('æ“ä½œ');
            actionFolder.add(params, 'uploadMusic');
            actionFolder.add(params, 'uploadPhotos');
            actionFolder.add(params, 'recordVideo');
            actionFolder.add(params, 'resetTree');
        }

        function updateBG(style) {
            switch(style) {
                case 'Pitch Black':
                    document.body.style.background = '#000';
                    break;
                case 'Aurora':
                    document.body.style.background = 'linear-gradient(to bottom, #001510, #00bf8f)';
                    break;
                case 'Deep Space':
                default:
                    document.body.style.background = 'radial-gradient(ellipse at center, #1a2a6c, #b21f1f, #fdbb2d)';
                    break;
            }
        }

        function startExperience() {
            const startScreen = document.getElementById('start-screen');
            const startBtn = document.getElementById('start-btn');
            
            startBtn.disabled = true;
            startBtn.textContent = 'è¿›å…¥ä¸­...';
            
            // æ·¡å‡ºå¼€å§‹ç•Œé¢
            startScreen.style.opacity = '0';
            
            setTimeout(() => {
                startScreen.style.display = 'none';
                
                // å°è¯•æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœéœ€è¦ï¼‰
                if (audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                
                state.isPlaying = true;
                logInfo("æ¬¢è¿æ¥åˆ°3Dåœ£è¯æ ‘ä¸–ç•Œï¼");
            }, 500);
        }

        function handleMusic(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const audioData = await audioCtx.decodeAudioData(e.target.result);
                    
                    if (audioSource) {
                        audioSource.stop();
                    }
                    
                    audioSource = audioCtx.createBufferSource();
                    audioSource.buffer = audioData;
                    
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 256;
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                    
                    audioSource.connect(analyser);
                    analyser.connect(audioCtx.destination);
                    audioSource.loop = true;
                    audioSource.start();
                    
                    logInfo("éŸ³ä¹å·²åŠ è½½ï¼");
                } catch (error) {
                    logError("éŸ³é¢‘åŠ è½½å¤±è´¥: " + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function handlePhotos(event) {
            const files = event.target.files;
            if (!files.length) return;
            
            // æ¸…é™¤ç°æœ‰ç…§ç‰‡
            while (photoGroup.children.length > 0) {
                const child = photoGroup.children[0];
                photoGroup.remove(child);
            }
            
            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // åˆ›å»ºåœ†å½¢ç…§ç‰‡
                        const canvas = document.createElement('canvas');
                        canvas.width = 256;
                        canvas.height = 256;
                        const ctx = canvas.getContext('2d');
                        
                        // ç»˜åˆ¶åœ†å½¢
                        ctx.beginPath();
                        ctx.arc(128, 128, 120, 0, Math.PI * 2);
                        ctx.clip();
                        
                        // ç»˜åˆ¶å›¾ç‰‡
                        ctx.drawImage(img, 0, 0, 256, 256);
                        
                        // æ·»åŠ è¾¹æ¡†
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.arc(128, 128, 120, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        const material = new THREE.SpriteMaterial({ map: texture });
                        const sprite = new THREE.Sprite(material);
                        
                        // è®¡ç®—å¿ƒå½¢ä½ç½®
                        const t = (index / files.length) * Math.PI * 2;
                        const heartX = 16 * Math.pow(Math.sin(t), 3);
                        const heartY = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                        
                        sprite.userData = {
                            treePos: new THREE.Vector3(
                                Math.cos(t) * 15,
                                (index / files.length) * params.treeHeight - params.treeHeight/2,
                                Math.sin(t) * 15
                            ),
                            heartPos: new THREE.Vector3(heartX * 0.8, heartY * 0.8, 25)
                        };
                        
                        sprite.position.copy(sprite.userData.treePos);
                        sprite.scale.set(4, 4, 1);
                        
                        photoGroup.add(sprite);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
            
            logInfo(`å·²åŠ è½½ ${files.length} å¼ ç…§ç‰‡`);
        }

        function toggleRecording() {
            const btn = document.getElementById('record-btn');
            
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                btn.classList.remove('recording');
                logInfo("å½•åˆ¶å·²åœæ­¢");
            } else {
                try {
                    const stream = renderer.domElement.captureStream(30);
                    recordedChunks = [];
                    
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm'
                    });
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(recordedChunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `åœ£è¯æ ‘_${Date.now()}.webm`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    };
                    
                    mediaRecorder.start();
                    btn.classList.add('recording');
                    logInfo("å¼€å§‹å½•åˆ¶...");
                } catch (error) {
                    logError("å½•åˆ¶å¤±è´¥: " + error.message);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            
            // æ›´æ–°éŸ³é¢‘åˆ†æ
            let beat = 0;
            if (analyser && dataArray) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < 20; i++) {
                    sum += dataArray[i];
                }
                beat = (sum / 20) / 255.0 * params.audioSens;
            }
            
            // æ›´æ–°shader uniforms
            if (uniforms) {
                uniforms.uTime.value = time;
                uniforms.uBeat.value = beat;
                
                // å¹³æ»‘æ›´æ–°æ··åˆå› å­ï¼ˆæ ¹æ®å·¦æ‰‹å¼ å¼€åº¦ï¼‰
                const targetMix = state.leftHandOpen;
                uniforms.uMixFactor.value += (targetMix - uniforms.uMixFactor.value) * params.reactionSpeed;
            }
            
            // æ›´æ–°æ˜Ÿæ˜Ÿ
            if (starMesh) {
                starMesh.rotation.y = time * 0.2;
                const starHeight = params.treeHeight / 2 + 5;
                starMesh.position.y = starHeight;
                starMesh.scale.setScalar(1 + beat * 0.3);
            }
            
            // æ›´æ–°é›ªèŠ±
            if (snowSystem) {
                const positions = snowSystem.geometry.attributes.position.array;
                for (let i = 0; i < params.snowCount; i++) {
                    const index = i * 3;
                    positions[index + 1] -= params.snowSpeed * 0.05;
                    positions[index] += Math.sin(time + i * 0.01) * params.windStrength * 0.05;
                    
                    if (positions[index + 1] < -30) {
                        positions[index + 1] = 50;
                        positions[index] = (Math.random() - 0.5) * 100;
                        positions[index + 2] = (Math.random() - 0.5) * 100;
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // æ›´æ–°ç…§ç‰‡
            if (photoGroup && photoGroup.children.length > 0) {
                const targetPos = state.rightHandPinch > 0.5 ? 'heartPos' : 'treePos';
                
                photoGroup.children.forEach((sprite, index) => {
                    const target = sprite.userData[targetPos];
                    sprite.position.lerp(target, 0.1);
                    
                    // æ ¹æ®éŸ³ä¹è·³åŠ¨
                    if (beat > 0.1) {
                        const scale = 4 + beat;
                        sprite.scale.set(scale, scale, 1);
                    }
                });
                
                // å¦‚æœæ˜¯æ ‘å½¢æ’åˆ—ï¼Œè·Ÿéšç›¸æœºæ—‹è½¬
                if (targetPos === 'treePos') {
                    photoGroup.rotation.y = -controls.getAzimuthalAngle();
                }
            }
            
            // æ›´æ–°æ§åˆ¶å™¨
            controls.update();
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }

        // æ£€æŸ¥æœ¬åœ°æ–‡ä»¶è¿è¡Œ
        if (window.location.protocol === 'file:') {
            document.getElementById('status-msg').innerHTML = 
                '<span style="color:#ff5555">âš ï¸ è¯·ä½¿ç”¨Live Serverè¿è¡Œï¼<br>ä¸èƒ½ç›´æ¥åŒå‡»æ‰“å¼€HTMLæ–‡ä»¶</span>';
            document.getElementById('start-btn').disabled = true;
        } else {
            // å¯åŠ¨åº”ç”¨
            init();
        }
    </script>
</body>
</html>