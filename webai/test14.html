<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº¤äº’å¼ç²’å­åœ£è¯æ ‘</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a2a, #1a0033);
            color: white;
            overflow: hidden;
            height: 100vh;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #header {
            text-align: center;
            padding: 15px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
        }
        
        #header h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #ff3366, #33ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        #controls {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #ff3366, #ff9933);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.5);
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.8);
        }
        
        #status {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 15px;
            margin-top: 10px;
            display: inline-block;
        }
        
        #main {
            flex: 1;
            display: flex;
            position: relative;
        }
        
        #canvasContainer {
            flex: 1;
            position: relative;
        }
        
        #webcamContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            border: 2px solid #33ccff;
            z-index: 50;
        }
        
        #webcamVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #gestureCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #gestureStatus {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            font-size: 14px;
            border-left: 4px solid #33ccff;
        }
        
        #photosContainer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: none;
        }
        
        .photo-frame {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            border: 3px solid #ffcc00;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            background: black;
        }
        
        .photo-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .photo-frame.enlarged {
            width: 250px;
            height: 250px;
            z-index: 100;
            box-shadow: 0 0 30px rgba(255, 204, 0, 1);
            border: 5px solid #ff3366;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            border-left: 4px solid #ff3366;
        }
        
        #instructions h3 {
            margin-bottom: 10px;
            color: #33ccff;
        }
        
        #instructions ul {
            list-style: none;
        }
        
        #instructions li {
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
        }
        
        #instructions li:before {
            content: "ğŸ„";
            position: absolute;
            left: 0;
        }
        
        .hidden {
            display: none !important;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-top: 5px solid #ff3366;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1001;
            max-width: 80%;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>ğŸ„ äº¤äº’å¼ç²’å­åœ£è¯æ ‘ ğŸ„</h1>
            <div id="controls">
                <button id="selectFolderBtn">ğŸ“ é€‰æ‹©å›¾ç‰‡æ–‡ä»¶å¤¹</button>
                <button id="startCameraBtn">ğŸ“· å¼€å¯æ‘„åƒå¤´</button>
                <button id="resetTreeBtn">ğŸ”„ é‡ç½®åœ£è¯æ ‘</button>
                <div id="status">çŠ¶æ€: ç­‰å¾…åˆå§‹åŒ–...</div>
            </div>
        </div>
        
        <div id="main">
            <div id="canvasContainer">
                <canvas id="mainCanvas"></canvas>
            </div>
            
            <div id="webcamContainer" class="hidden">
                <video id="webcamVideo" autoplay playsinline></video>
                <canvas id="gestureCanvas"></canvas>
                <div id="gestureStatus">æ‰‹åŠ¿: æ£€æµ‹ä¸­...</div>
            </div>
            
            <div id="photosContainer"></div>
            
            <div id="instructions">
                <h3>æ‰‹åŠ¿æ§åˆ¶è¯´æ˜:</h3>
                <ul>
                    <li>ğŸ¤š æ‰‹æŒå±•å¼€: å±•å¼€åœ£è¯æ ‘ï¼Œç…§ç‰‡æ’æˆç›´çº¿</li>
                    <li>âœŠ æ‰‹æ¡æ‹³: ä¿æŒåœ£è¯æ ‘çŠ¶æ€</li>
                    <li>ğŸ‘Œ OKæ‰‹åŠ¿: æ”¾å¤§æœ€å‰é¢çš„ç…§ç‰‡</li>
                    <li>ğŸ‘‹ æ‰‹éƒ¨ç§»åŠ¨: æ§åˆ¶åœ£è¯æ ‘æ—‹è½¬å’Œç…§ç‰‡æ°´å¹³ç§»åŠ¨</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div>æ­£åœ¨åˆå§‹åŒ–...</div>
    </div>
    
    <div id="error" class="hidden"></div>

    <!-- å¼•å…¥æ‰‹åŠ¿è¯†åˆ«åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>

    <script>
        // å…¨å±€å˜é‡
        let camera = null;
        let scene = null;
        let renderer = null;
        let treeParticles = [];
        let photos = [];
        let selectedPhotos = [];
        let photoFrames = [];
        let handDetector = null;
        let isCameraActive = false;
        let lastGesture = '';
        let isHandDetected = false;
        let handPosition = { x: 0, y: 0 };
        let treeRotation = { x: 0, y: 0 };
        let treeState = 'folded'; // 'folded' æˆ– 'expanded'
        let targetTreeRotation = { x: 0, y: 0 };
        let photoPositions = [];
        const PHOTO_COUNT = 8;
        let selectedFolder = null;
        let isOKGesture = false;
        let enlargedPhotoIndex = -1;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', init);

        async function init() {
            try {
                // åˆå§‹åŒ–3Dåœºæ™¯
                initThreeJS();
                
                // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
                setupEventListeners();
                
                // åˆ›å»ºåˆå§‹åœ£è¯æ ‘
                createChristmasTree();
                
                // éšè—åŠ è½½ç•Œé¢
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                }, 1000);
                
                updateStatus('å°±ç»ª - è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶å¤¹å¹¶å¼€å¯æ‘„åƒå¤´');
                
            } catch (error) {
                showError('åˆå§‹åŒ–å¤±è´¥: ' + error.message);
            }
        }

        function initThreeJS() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a2a);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 15);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            const canvas = document.getElementById('mainCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas,
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // æ·»åŠ ç‚¹å…‰æº
            const pointLight = new THREE.PointLight(0xff3366, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            // çª—å£å¤§å°è°ƒæ•´å¤„ç†
            window.addEventListener('resize', onWindowResize);
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
        }

        function createChristmasTree() {
            // æ¸…é™¤ç°æœ‰çš„ç²’å­
            treeParticles.forEach(particle => {
                scene.remove(particle);
            });
            treeParticles = [];
            
            const particleCount = 1500;
            const treeHeight = 8;
            const treeWidth = 4;
            
            // åˆ›å»ºç²’å­æè´¨
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x33ff33,
                size: 0.1,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                // åˆ›å»ºé”¥å½¢åˆ†å¸ƒï¼ˆåœ£è¯æ ‘å½¢çŠ¶ï¼‰
                const radius = Math.random() * treeWidth;
                const angle = Math.random() * Math.PI * 2;
                const height = Math.random() * treeHeight;
                const y = height - treeHeight / 2;
                
                // æ ¹æ®é«˜åº¦è°ƒæ•´åŠå¾„ï¼Œå½¢æˆé”¥å½¢
                const adjustedRadius = radius * (1 - height / treeHeight);
                const x = Math.cos(angle) * adjustedRadius;
                const z = Math.sin(angle) * adjustedRadius;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // è®¾ç½®é¢œè‰²ï¼ˆä»ä¸‹åˆ°ä¸Šæ¸å˜ï¼‰
                const hue = 0.3 + (height / treeHeight) * 0.2; // ç»¿è‰²åˆ°æµ…ç»¿è‰²
                const saturation = 0.8;
                const lightness = 0.5 + Math.random() * 0.3;
                
                const rgb = hslToRgb(hue, saturation, lightness);
                colors[i * 3] = rgb[0];
                colors[i * 3 + 1] = rgb[1];
                colors[i * 3 + 2] = rgb[2];
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particles = new THREE.Points(geometry, particleMaterial);
            scene.add(particles);
            treeParticles.push(particles);
            
            // æ·»åŠ æ ‘é¡¶æ˜Ÿæ˜Ÿ
            const starGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const starMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 2
            });
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.y = treeHeight / 2 + 0.5;
            scene.add(star);
            treeParticles.push(star);
        }

        function setupEventListeners() {
            document.getElementById('selectFolderBtn').addEventListener('click', selectFolder);
            document.getElementById('startCameraBtn').addEventListener('click', startCamera);
            document.getElementById('resetTreeBtn').addEventListener('click', resetTree);
        }

        async function selectFolder() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.webkitdirectory = true;
                input.multiple = true;
                input.accept = 'image/*';
                
                input.onchange = async (e) => {
                    const files = Array.from(e.target.files);
                    const imageFiles = files.filter(file => 
                        file.type.startsWith('image/')
                    );
                    
                    if (imageFiles.length === 0) {
                        showError('æ–‡ä»¶å¤¹ä¸­æ²¡æœ‰æ‰¾åˆ°å›¾ç‰‡æ–‡ä»¶');
                        return;
                    }
                    
                    photos = imageFiles;
                    selectRandomPhotos();
                    updateStatus(`å·²åŠ è½½ ${photos.length} å¼ å›¾ç‰‡ï¼Œé€‰æ‹©äº† ${selectedPhotos.length} å¼ `);
                };
                
                input.click();
            } catch (error) {
                showError('é€‰æ‹©æ–‡ä»¶å¤¹å¤±è´¥: ' + error.message);
            }
        }

        function selectRandomPhotos() {
            if (photos.length === 0) return;
            
            selectedPhotos = [];
            const count = Math.min(PHOTO_COUNT, photos.length);
            const shuffled = [...photos].sort(() => 0.5 - Math.random());
            
            for (let i = 0; i < count; i++) {
                selectedPhotos.push(shuffled[i]);
            }
            
            displayPhotos();
        }

        function displayPhotos() {
            const container = document.getElementById('photosContainer');
            container.innerHTML = '';
            photoFrames = [];
            
            selectedPhotos.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const frame = document.createElement('div');
                    frame.className = 'photo-frame';
                    frame.style.zIndex = index;
                    
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    img.alt = `Photo ${index + 1}`;
                    
                    frame.appendChild(img);
                    container.appendChild(frame);
                    photoFrames.push(frame);
                    
                    // åˆå§‹ä½ç½®ï¼ˆåœ¨æ ‘ä¸‹ï¼‰
                    updatePhotoPosition(index, false);
                };
                reader.readAsDataURL(file);
            });
        }

        function updatePhotoPosition(index, expanded) {
            if (!photoFrames[index]) return;
            
            const frame = photoFrames[index];
            
            if (expanded) {
                // å±•å¼€çŠ¶æ€ï¼šæ°´å¹³æ’åˆ—ï¼Œé«˜åº¦æµ®åŠ¨
                const spacing = window.innerWidth / (selectedPhotos.length + 1);
                const x = (index + 1) * spacing - window.innerWidth / 2;
                const y = Math.sin(Date.now() * 0.001 + index) * 50 - 100;
                
                frame.style.transform = `translate(${x}px, ${y}px)`;
                frame.style.transition = 'all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                
                // æ ¹æ®æ‰‹åŠ¿ä½ç½®è°ƒæ•´æ°´å¹³ä½ç½®
                if (isHandDetected) {
                    const offset = (handPosition.x - 0.5) * 500;
                    frame.style.transform = `translate(${x + offset}px, ${y}px)`;
                }
            } else {
                // æŠ˜å çŠ¶æ€ï¼šå›´ç»•åœ£è¯æ ‘
                const angle = (index / selectedPhotos.length) * Math.PI * 2;
                const radius = 200 + Math.sin(Date.now() * 0.002 + index) * 20;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius * 0.5;
                
                frame.style.transform = `translate(calc(50% + ${x}px), calc(50% + ${y}px))`;
                frame.style.transition = 'all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
            }
            
            // å¤„ç†æ”¾å¤§æ•ˆæœ
            if (enlargedPhotoIndex === index) {
                frame.classList.add('enlarged');
                frame.style.zIndex = 1000;
            } else {
                frame.classList.remove('enlarged');
                frame.style.zIndex = index;
            }
        }

        async function startCamera() {
            try {
                updateStatus('æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´...');
                
                const video = document.getElementById('webcamVideo');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });
                
                video.srcObject = stream;
                document.getElementById('webcamContainer').classList.remove('hidden');
                isCameraActive = true;
                
                // ç­‰å¾…è§†é¢‘åŠ è½½
                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
                // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
                await initHandDetection();
                
                updateStatus('æ‘„åƒå¤´å·²å¼€å¯ - å¼€å§‹æ‰‹åŠ¿è¯†åˆ«');
                
            } catch (error) {
                showError('æ‘„åƒå¤´å¼€å¯å¤±è´¥: ' + error.message);
            }
        }

        async function initHandDetection() {
            try {
                // åŠ è½½TensorFlowæ¨¡å‹
                await tf.setBackend('webgl');
                
                // åŠ è½½MediaPipe Handsæ¨¡å‹
                const hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults((results) => {
                    processHandResults(results);
                });
                
                // å¼€å§‹å¤„ç†è§†é¢‘å¸§
                const video = document.getElementById('webcamVideo');
                const canvasElement = document.getElementById('gestureCanvas');
                const canvasCtx = canvasElement.getContext('2d');
                
                canvasElement.width = video.videoWidth;
                canvasElement.height = video.videoHeight;
                
                async function processFrame() {
                    if (!isCameraActive) return;
                    
                    canvasCtx.save();
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    canvasCtx.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
                    
                    await hands.send({ image: video });
                    
                    canvasCtx.restore();
                    
                    requestAnimationFrame(processFrame);
                }
                
                processFrame();
                
            } catch (error) {
                console.error('æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥:', error);
                updateStatus('æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ‰‹åŠ¿');
                startSimulatedGestures();
            }
        }

        function processHandResults(results) {
            const canvasElement = document.getElementById('gestureCanvas');
            const canvasCtx = canvasElement.getContext('2d');
            
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹
                canvasCtx.strokeStyle = '#00ff00';
                canvasCtx.lineWidth = 2;
                
                // ç»˜åˆ¶è¿æ¥çº¿
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], // æ‹‡æŒ‡
                    [0, 5], [5, 6], [6, 7], [7, 8], // é£ŸæŒ‡
                    [0, 9], [9, 10], [10, 11], [11, 12], // ä¸­æŒ‡
                    [0, 13], [13, 14], [14, 15], [15, 16], // æ— åæŒ‡
                    [0, 17], [17, 18], [18, 19], [19, 20], // å°æŒ‡
                    [5, 9], [9, 13], [13, 17] // æ‰‹æŒ
                ];
                
                connections.forEach(([start, end]) => {
                    const startPoint = landmarks[start];
                    const endPoint = landmarks[end];
                    
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
                    canvasCtx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
                    canvasCtx.stroke();
                });
                
                // ç»˜åˆ¶å…³é”®ç‚¹
                landmarks.forEach((landmark, index) => {
                    canvasCtx.beginPath();
                    canvasCtx.arc(
                        landmark.x * canvasElement.width,
                        landmark.y * canvasElement.height,
                        3, 0, 2 * Math.PI
                    );
                    canvasCtx.fillStyle = index === 8 ? '#ff0000' : '#00ffff';
                    canvasCtx.fill();
                });
                
                // è®¡ç®—æ‰‹éƒ¨ä½ç½®
                handPosition.x = landmarks[9].x; // ä¸­æŒ‡æ ¹éƒ¨
                handPosition.y = landmarks[9].y;
                
                // è¯†åˆ«æ‰‹åŠ¿
                detectGesture(landmarks);
                
                // æ›´æ–°æ‰‹åŠ¿çŠ¶æ€æ˜¾ç¤º
                document.getElementById('gestureStatus').textContent = 
                    `æ‰‹åŠ¿: ${lastGesture} | X: ${handPosition.x.toFixed(2)} | Y: ${handPosition.y.toFixed(2)}`;
                
            } else {
                isHandDetected = false;
                lastGesture = 'æœªæ£€æµ‹åˆ°æ‰‹';
                document.getElementById('gestureStatus').textContent = 'æ‰‹åŠ¿: æœªæ£€æµ‹åˆ°æ‰‹';
            }
        }

        function detectGesture(landmarks) {
            // è®¡ç®—æŒ‡å°–åˆ°æ‰‹æŒæ ¹éƒ¨çš„è·ç¦»
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];
            
            // è®¡ç®—æ‰‹æŒ‡å±•å¼€ç¨‹åº¦
            const fingerDistances = [
                distance(thumbTip, wrist),
                distance(indexTip, wrist),
                distance(middleTip, wrist),
                distance(ringTip, wrist),
                distance(pinkyTip, wrist)
            ];
            
            const avgDistance = fingerDistances.reduce((a, b) => a + b) / fingerDistances.length;
            
            // æ£€æµ‹æ‰‹æŒå±•å¼€
            let fingersExtended = 0;
            fingerDistances.forEach(dist => {
                if (dist > avgDistance * 0.8) {
                    fingersExtended++;
                }
            });
            
            // æ£€æµ‹OKæ‰‹åŠ¿ï¼ˆé£ŸæŒ‡å’Œæ‹‡æŒ‡æ¥è§¦ï¼‰
            const thumbIndexDistance = distance(thumbTip, indexTip);
            const isThumbIndexClose = thumbIndexDistance < 0.05;
            
            // æ£€æµ‹æ¡æ‹³
            const isFist = fingersExtended <= 1;
            
            // æ›´æ–°æ‰‹åŠ¿çŠ¶æ€
            if (isThumbIndexClose && fingersExtended >= 3) {
                lastGesture = 'ğŸ‘Œ OKæ‰‹åŠ¿';
                if (!isOKGesture) {
                    isOKGesture = true;
                    toggleEnlargePhoto();
                }
            } else {
                isOKGesture = false;
                
                if (fingersExtended >= 4) {
                    lastGesture = 'ğŸ¤š æ‰‹æŒå±•å¼€';
                    treeState = 'expanded';
                } else if (isFist) {
                    lastGesture = 'âœŠ æ‰‹æ¡æ‹³';
                    treeState = 'folded';
                } else {
                    lastGesture = 'ğŸ¤ å…¶ä»–æ‰‹åŠ¿';
                }
            }
            
            // æ ¹æ®æ‰‹éƒ¨ä½ç½®æ§åˆ¶æ—‹è½¬
            if (isHandDetected) {
                targetTreeRotation.y = (handPosition.x - 0.5) * Math.PI;
                targetTreeRotation.x = (handPosition.y - 0.5) * Math.PI * 0.5;
            }
        }

        function distance(point1, point2) {
            return Math.sqrt(
                Math.pow(point1.x - point2.x, 2) +
                Math.pow(point1.y - point2.y, 2) +
                Math.pow(point1.z - point2.z, 2)
            );
        }

        function toggleEnlargePhoto() {
            if (selectedPhotos.length === 0) return;
            
            if (enlargedPhotoIndex >= 0) {
                enlargedPhotoIndex = -1;
            } else {
                // æ”¾å¤§æœ€å‰é¢çš„ç…§ç‰‡
                enlargedPhotoIndex = 0;
            }
        }

        function startSimulatedGestures() {
            // æ¨¡æ‹Ÿæ‰‹åŠ¿ç”¨äºæµ‹è¯•
            let gestureIndex = 0;
            const gestures = ['ğŸ¤š æ‰‹æŒå±•å¼€', 'âœŠ æ‰‹æ¡æ‹³', 'ğŸ‘Œ OKæ‰‹åŠ¿'];
            
            setInterval(() => {
                if (!isCameraActive) return;
                
                isHandDetected = true;
                handPosition.x = 0.5 + Math.sin(Date.now() * 0.001) * 0.3;
                handPosition.y = 0.5 + Math.cos(Date.now() * 0.001) * 0.2;
                
                lastGesture = gestures[gestureIndex];
                gestureIndex = (gestureIndex + 1) % gestures.length;
                
                // æ¨¡æ‹Ÿæ‰‹åŠ¿æ•ˆæœ
                if (lastGesture === 'ğŸ¤š æ‰‹æŒå±•å¼€') {
                    treeState = 'expanded';
                } else if (lastGesture === 'âœŠ æ‰‹æ¡æ‹³') {
                    treeState = 'folded';
                } else if (lastGesture === 'ğŸ‘Œ OKæ‰‹åŠ¿') {
                    toggleEnlargePhoto();
                }
                
                targetTreeRotation.y = (handPosition.x - 0.5) * Math.PI;
                targetTreeRotation.x = (handPosition.y - 0.5) * Math.PI * 0.5;
                
                document.getElementById('gestureStatus').textContent = 
                    `æ‰‹åŠ¿: ${lastGesture} (æ¨¡æ‹Ÿ) | X: ${handPosition.x.toFixed(2)} | Y: ${handPosition.y.toFixed(2)}`;
                
            }, 3000);
        }

        function resetTree() {
            treeState = 'folded';
            targetTreeRotation = { x: 0, y: 0 };
            enlargedPhotoIndex = -1;
            selectRandomPhotos();
            updateStatus('åœ£è¯æ ‘å·²é‡ç½®');
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // å¹³æ»‘æ—‹è½¬è¿‡æ¸¡
            const rotationSpeed = 0.05;
            treeRotation.x += (targetTreeRotation.x - treeRotation.x) * rotationSpeed;
            treeRotation.y += (targetTreeRotation.y - treeRotation.y) * rotationSpeed;
            
            // åº”ç”¨æ—‹è½¬åˆ°åœ£è¯æ ‘ç²’å­
            treeParticles.forEach(particle => {
                particle.rotation.x = treeRotation.x;
                particle.rotation.y = treeRotation.y;
            });
            
            // æ·»åŠ ç²’å­åŠ¨ç”»
            if (treeParticles[0]) {
                const positions = treeParticles[0].geometry.attributes.position.array;
                const time = Date.now() * 0.001;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // æ·»åŠ è½»å¾®çš„æµ®åŠ¨æ•ˆæœ
                    positions[i + 1] += Math.sin(time + positions[i] + positions[i + 2]) * 0.001;
                }
                
                treeParticles[0].geometry.attributes.position.needsUpdate = true;
                
                // éšæœºé—ªçƒæ•ˆæœ
                const colors = treeParticles[0].geometry.attributes.color.array;
                for (let i = 0; i < colors.length; i += 3) {
                    const flicker = 0.9 + Math.random() * 0.2;
                    colors[i] *= flicker;
                    colors[i + 1] *= flicker;
                    colors[i + 2] *= flicker;
                }
                treeParticles[0].geometry.attributes.color.needsUpdate = true;
            }
            
            // æ›´æ–°ç…§ç‰‡ä½ç½®
            photoFrames.forEach((frame, index) => {
                updatePhotoPosition(index, treeState === 'expanded');
            });
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = `çŠ¶æ€: ${message}`;
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
            
            setTimeout(() => {
                errorDiv.classList.add('hidden');
            }, 5000);
        }

        // HSLè½¬RGBè¾…åŠ©å‡½æ•°
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [r, g, b];
        }

        // é˜²æ­¢å³é”®èœå•
        document.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>